{"ast":null,"code":"import _slicedToArray from\"/Users/arlosb/Documents/GitHub/new react app/test1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import React,{useEffect,useMemo,useRef,useState}from'react';import'./Tile.css';function useForceUpdate(){var _useState=useState(0),_useState2=_slicedToArray(_useState,2),value=_useState2[0],setValue=_useState2[1];// integer state\nreturn function(){return setValue(function(value){return value+1;});};// update the state to force render\n}function getTrackUnavailableMessage(kind,trackState){if(!trackState)return;switch(trackState.state){case'blocked':if(trackState.blocked.byPermissions){return\"\".concat(kind,\" permission denied\");}else if(trackState.blocked.byDeviceMissing){return\"\".concat(kind,\" device missing\");}return\"\".concat(kind,\" blocked\");case'off':if(trackState.off.byUser){return\"\".concat(kind,\" muted\");}else if(trackState.off.byBandwidth){return\"\".concat(kind,\" muted to save bandwidth\");}return\"\".concat(kind,\" off\");case'sendable':return\"\".concat(kind,\" not subscribed\");case'loading':return\"\".concat(kind,\" loading...\");case'interrupted':return\"\".concat(kind,\" interrupted\");case'playable':return null;}}/**\n * Props\n * - videoTrackState: DailyTrackState?\n * - audioTrackState: DailyTrackState?\n * - isLocalPerson: boolean\n * - isAudioOnly: boolean\n * - isLarge: boolean\n * - disableCornerMessage: boolean\n * - onClick: Function\n * -isScreenShare: boolean\n */export default function Tile(props){var videoEl=useRef(null);var audioEl=useRef(null);var forceUpdate=useForceUpdate();window.updateTile=function(){forceUpdate();};var videoTrack=useMemo(function(){return props.videoTrackState&&props.videoTrackState.state==='playable'&&(props.isLocalPerson||props.videoTrackState.subscribed===true)?props.videoTrackState.track:null;},[props.videoTrackState]);var audioTrack=useMemo(function(){if(!props.audioTrackState||!props.audioTrackState.track||props.audioTrackState.state!=='playable'||props.audioTrackState.subscribed===false){return null;}// if(props.disableCornerMessage) {console.log('Is a screen share');}\nif(props.isAudioOnly){props.audioTrackState.track.isFiltered=true;}else{props.audioTrackState.track.isFiltered=false;}if(props.isScreenShare){props.audioTrackState.track.isScreenShare=true;}else{props.audioTrackState.track.isScreenShare=false;}return props.audioTrackState.track;},[props.audioTrackState]);var videoUnavailableMessage=useMemo(function(){return getTrackUnavailableMessage('video',props.videoTrackState);},[props.videoTrackState]);var audioUnavailableMessage=useMemo(function(){return getTrackUnavailableMessage('audio',props.audioTrackState);},[props.audioTrackState]);/**\n   * When video track changes, update video srcObject\n   */useEffect(function(){videoEl.current&&(videoEl.current.srcObject=new MediaStream([videoTrack]));},[videoTrack]);/**\n   * When audio track changes, update audio srcObject\n   */useEffect(function(){if(audioEl.current){// TODO: PUT THIS BACK\n// //create audio stream\n// window.stream= window.stream || new MediaStream([audioTrack]);\n// //workaround for bug in Chrome, see: https://bit.ly/3ryn1fW\n//       window.mutedAudio = window.mutedAudio || new Audio(); \n//       window.mutedAudio.muted = true;\n//       if(!window.mutedAudio.srcObject) {window.mutedAudio.srcObject = window.stream;}\n//       window.mutedAudio.paused && window.mutedAudio.play(); \n// //create Audio Context and destination\n// window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n// let audioSourceNode = window.audioCtx.createMediaStreamSource(window.stream);\n// let destination = window.audioCtx.createMediaStreamDestination();\n// //gain Node\n// let gainNode = window.audioCtx.createGain();\n// //panner Node\n// var panNode = window.audioCtx.createStereoPanner();\n// //splitter\n// if(audioTrack.isFiltered) {\n//   console.log('**FILTERING LIVE TRACK**')\n//         //adjust nodes\n//         gainNode.gain.value=1;\n//         panNode.pan.value=1;      \n//         //Pipe source through nodes to destination\n//       audioSourceNode.connect(gainNode).connect(panNode).connect(destination);\n// } \n// else if(audioTrack.isScreenShare) {\n//   //for everyone, just piping the received audio (which was the left channel of the original video) straight through\n//   console.log('***GETTING SCREENSHARE AUDIO')\n//   audioSourceNode.connect(destination);\n//   ///OLD CODE FOR IF IT RECEIVED STEREO AUDIO:\n//   // const splitterNode = new ChannelSplitterNode(audioCtx, { numberOfOutputs: 2 });\n//   // const splitterNodeLL = new ChannelSplitterNode(audioCtx, { numberOfOutputs: 2 });\n//   // const mergerNode = new ChannelMergerNode(audioCtx, { numberOfInputs: 2 });\n//   // const mergerNodeR = new ChannelMergerNode(audioCtx, { numberOfInputs: 2 });\n//   // const volumeNodeL = new GainNode(audioCtx);\n//   // const volumeNodeR = new GainNode(audioCtx);\n//   // if(window.myRole.includes('Actor')) {   //For actors, mix left channel into both sides and keep right channel\n//   //   console.log('**FILTERING: SCREENSHARE AUDIO FOR ACTOR**')\n//   //   // //split audio source into 2 channels: 0 (left), and 1(right)\n//   //   // audioSourceNode.connect(splitterNode)  \n//   //   // splitterNode.connect(splitterNodeLL,0); //split left channel again\n//   //   // //mix the left and right into the new right channel\n//   //   // splitterNodeLL.connect(mergerNodeR, 0, 1); // Merge right of the left channel into right side\n//   //   // splitterNode.connect(mergerNodeR, 0, 1); // Merge right channel into right side\n//   //   // //merge far left and new right\n//   //   // splitterNodeLL.connect(mergerNode, 0, 0);\n//   //   // mergerNodeR.connect(mergerNode, 0, 1);\n//   //   audioSourceNode.connect(mergerNode,0,0);\n//   //   audioSourceNode.connect(mergerNode,0,1);\n//   // } else {        //For everyone else , mix left channel into both sides and mute right channel\n//   //   console.log('**FILTERING: SCREENSHARE AUDIO FOR OBSERVER**')\n//   //   //split audio source into 2 channels: 0 (left), and 1(right)\n//   //   audioSourceNode.connect(splitterNode)\n//   //   //adjust channels separately\n//   //   splitterNode.connect(volumeNodeL, 0); // connect Left channel to its volume node\n//   //   splitterNode.connect(volumeNodeR, 1); // connect Right channel to its volume node\n//   //   volumeNodeL.gain.value = 1; //set Left volume\n//   //   volumeNodeR.gain.value = 1; //set Right volume\n//   //   //merge the channels\n//   //   volumeNodeL.connect(mergerNode, 0, 0); // Merge left channel\n//   //   volumeNodeR.connect(mergerNode, 0, 1); // Merge right channel\n//   //   // volumeNodeR.connect(mergerNode, 0, 0);\n//   // }\n//   //   //finally, connect to destination\n//   //   mergerNode.connect(destination);\n// }\n// else {      //For normal live tracks\n//   console.log('***NOT FILTERING: LIVE TRACK***')\n//    //Pipe source *straight* to destination\n//   audioSourceNode.connect(gainNode).connect(destination);\n// }\n//     //Attach to the audio element\n//     audioEl.current.srcObject = destination.stream;\n//END TODO\n// how to do this without audiocontext:\naudioEl.current.srcObject=new MediaStream([audioTrack]);// for debugging\n// window.destination=destination; \n// window.audioTrack=audioTrack;\n// window.audioEl = audioEl;\n}},[audioTrack,window.sessionState]);function getVideoComponent(){return videoTrack&&/*#__PURE__*/React.createElement(\"video\",{autoPlay:true,muted:true,playsInline:true,ref:videoEl});}function getAudioComponent(){return!props.isLocalPerson&&audioTrack&&/*#__PURE__*/React.createElement(\"audio\",{autoPlay:true,playsInline:true,ref:audioEl},\" \");}function getOverlayComponent(){// Show overlay when video is unavailable. Audio may be unavailable too.\nreturn videoTrack&&videoUnavailableMessage&&/*#__PURE__*/React.createElement(\"p\",{className:\"overlay\"},videoUnavailableMessage);}function getCornerMessageComponent(){// Show corner message when only audio is unavailable.\nreturn!props.disableCornerMessage&&audioUnavailableMessage&&!videoUnavailableMessage&&/*#__PURE__*/React.createElement(\"p\",{className:\"corner\"},audioUnavailableMessage);}function getClassNames(){var classNames='tile';classNames+=props.isLarge?' large':' small';props.isLocalPerson&&(classNames+=' local');return classNames;}return/*#__PURE__*/ (///TODO change to block : none\nReact.createElement(\"div\",{className:getClassNames(),onClick:props.onClick,style:{display:videoTrack?\"block\":\"none\"}},/*#__PURE__*/React.createElement(\"div\",{className:\"background\"}),getOverlayComponent(),getVideoComponent(),videoTrack&&getCornerMessageComponent(),getAudioComponent()));}","map":{"version":3,"sources":["/Users/arlosb/Documents/GitHub/new react app/test1/src/components/Tile/Tile.js"],"names":["React","useEffect","useMemo","useRef","useState","useForceUpdate","value","setValue","getTrackUnavailableMessage","kind","trackState","state","blocked","byPermissions","byDeviceMissing","off","byUser","byBandwidth","Tile","props","videoEl","audioEl","forceUpdate","window","updateTile","videoTrack","videoTrackState","isLocalPerson","subscribed","track","audioTrack","audioTrackState","isAudioOnly","isFiltered","isScreenShare","videoUnavailableMessage","audioUnavailableMessage","current","srcObject","MediaStream","sessionState","getVideoComponent","getAudioComponent","getOverlayComponent","getCornerMessageComponent","disableCornerMessage","getClassNames","classNames","isLarge","onClick","display"],"mappings":"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","sourcesContent":["import React, { useEffect, useMemo, useRef, useState } from 'react';\nimport './Tile.css';\nfunction useForceUpdate(){\n  const [value, setValue] = useState(0); // integer state\n  return () => setValue(value => value + 1); // update the state to force render\n}\n\nfunction getTrackUnavailableMessage(kind, trackState) {\n  if (!trackState) return;\n  switch (trackState.state) {\n    case 'blocked':\n      if (trackState.blocked.byPermissions) {\n        return `${kind} permission denied`;\n      } else if (trackState.blocked.byDeviceMissing) {\n        return `${kind} device missing`;\n      }\n      return `${kind} blocked`;\n    case 'off':\n      if (trackState.off.byUser) {\n        return `${kind} muted`;\n      } else if (trackState.off.byBandwidth) {\n        return `${kind} muted to save bandwidth`;\n      }\n      return `${kind} off`;\n    case 'sendable':\n      return `${kind} not subscribed`;\n    case 'loading':\n      return `${kind} loading...`;\n    case 'interrupted':\n      return `${kind} interrupted`;\n    case 'playable':\n      return null;\n  }\n}\n\n/**\n * Props\n * - videoTrackState: DailyTrackState?\n * - audioTrackState: DailyTrackState?\n * - isLocalPerson: boolean\n * - isAudioOnly: boolean\n * - isLarge: boolean\n * - disableCornerMessage: boolean\n * - onClick: Function\n * -isScreenShare: boolean\n */\nexport default function Tile(props) {\n  const videoEl = useRef(null);\n  const audioEl = useRef(null);\n  const forceUpdate = useForceUpdate();\n\n  window.updateTile = () => {\n    forceUpdate();\n  }\n\n  const videoTrack = useMemo(() => {\n    return props.videoTrackState && props.videoTrackState.state === 'playable' && (props.isLocalPerson || props.videoTrackState.subscribed === true)\n      ? props.videoTrackState.track\n      : null;\n  }, [props.videoTrackState]);\n\n  const audioTrack = useMemo(() => {\n\n    if (!props.audioTrackState || !props.audioTrackState.track || props.audioTrackState.state !== 'playable' || props.audioTrackState.subscribed === false) \n        {return null;}\n    // if(props.disableCornerMessage) {console.log('Is a screen share');}\n    if (props.isAudioOnly) {\n      props.audioTrackState.track.isFiltered=true;\n    } else {props.audioTrackState.track.isFiltered=false;}\n    if (props.isScreenShare) {\n      props.audioTrackState.track.isScreenShare=true;\n    } else {props.audioTrackState.track.isScreenShare=false;}\n    return props.audioTrackState.track\n  }, [props.audioTrackState]);\n\n  const videoUnavailableMessage = useMemo(() => {\n    return getTrackUnavailableMessage('video', props.videoTrackState);\n  }, [props.videoTrackState]);\n\n  const audioUnavailableMessage = useMemo(() => {\n    return getTrackUnavailableMessage('audio', props.audioTrackState);\n  }, [props.audioTrackState]);\n\n  /**\n   * When video track changes, update video srcObject\n   */\n  useEffect(() => {\n    videoEl.current &&\n      (videoEl.current.srcObject = new MediaStream([videoTrack]));\n  }, [videoTrack]);\n\n  /**\n   * When audio track changes, update audio srcObject\n   */\n  useEffect(() => {\n    if(audioEl.current) {\n\n\n\n        // TODO: PUT THIS BACK\n\n\n      // //create audio stream\n      // window.stream= window.stream || new MediaStream([audioTrack]);\n\n      // //workaround for bug in Chrome, see: https://bit.ly/3ryn1fW\n      //       window.mutedAudio = window.mutedAudio || new Audio(); \n      //       window.mutedAudio.muted = true;\n      //       if(!window.mutedAudio.srcObject) {window.mutedAudio.srcObject = window.stream;}\n      //       window.mutedAudio.paused && window.mutedAudio.play(); \n\n      // //create Audio Context and destination\n      // window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      // let audioSourceNode = window.audioCtx.createMediaStreamSource(window.stream);\n      // let destination = window.audioCtx.createMediaStreamDestination();\n\n      // //gain Node\n      // let gainNode = window.audioCtx.createGain();\n      // //panner Node\n      // var panNode = window.audioCtx.createStereoPanner();\n      // //splitter\n      \n\n\n\n\n\n      \n      // if(audioTrack.isFiltered) {\n      //   console.log('**FILTERING LIVE TRACK**')\n      //         //adjust nodes\n      //         gainNode.gain.value=1;\n      //         panNode.pan.value=1;      \n      //         //Pipe source through nodes to destination\n      //       audioSourceNode.connect(gainNode).connect(panNode).connect(destination);\n        \n      // } \n      // else if(audioTrack.isScreenShare) {\n\n      //   //for everyone, just piping the received audio (which was the left channel of the original video) straight through\n      //   console.log('***GETTING SCREENSHARE AUDIO')\n      //   audioSourceNode.connect(destination);\n\n\n\n      //   ///OLD CODE FOR IF IT RECEIVED STEREO AUDIO:\n        \n      //   // const splitterNode = new ChannelSplitterNode(audioCtx, { numberOfOutputs: 2 });\n      //   // const splitterNodeLL = new ChannelSplitterNode(audioCtx, { numberOfOutputs: 2 });\n      //   // const mergerNode = new ChannelMergerNode(audioCtx, { numberOfInputs: 2 });\n      //   // const mergerNodeR = new ChannelMergerNode(audioCtx, { numberOfInputs: 2 });\n      //   // const volumeNodeL = new GainNode(audioCtx);\n      //   // const volumeNodeR = new GainNode(audioCtx);\n      //   // if(window.myRole.includes('Actor')) {   //For actors, mix left channel into both sides and keep right channel\n      //   //   console.log('**FILTERING: SCREENSHARE AUDIO FOR ACTOR**')\n\n\n      //   //   // //split audio source into 2 channels: 0 (left), and 1(right)\n      //   //   // audioSourceNode.connect(splitterNode)  \n      //   //   // splitterNode.connect(splitterNodeLL,0); //split left channel again\n\n      //   //   // //mix the left and right into the new right channel\n      //   //   // splitterNodeLL.connect(mergerNodeR, 0, 1); // Merge right of the left channel into right side\n      //   //   // splitterNode.connect(mergerNodeR, 0, 1); // Merge right channel into right side\n\n      //   //   // //merge far left and new right\n      //   //   // splitterNodeLL.connect(mergerNode, 0, 0);\n      //   //   // mergerNodeR.connect(mergerNode, 0, 1);\n\n      //   //   audioSourceNode.connect(mergerNode,0,0);\n      //   //   audioSourceNode.connect(mergerNode,0,1);\n\n          \n\n      //   // } else {        //For everyone else , mix left channel into both sides and mute right channel\n      //   //   console.log('**FILTERING: SCREENSHARE AUDIO FOR OBSERVER**')\n\n      //   //   //split audio source into 2 channels: 0 (left), and 1(right)\n      //   //   audioSourceNode.connect(splitterNode)\n\n\n      //   //   //adjust channels separately\n      //   //   splitterNode.connect(volumeNodeL, 0); // connect Left channel to its volume node\n      //   //   splitterNode.connect(volumeNodeR, 1); // connect Right channel to its volume node\n      //   //   volumeNodeL.gain.value = 1; //set Left volume\n      //   //   volumeNodeR.gain.value = 1; //set Right volume\n\n      //   //   //merge the channels\n      //   //   volumeNodeL.connect(mergerNode, 0, 0); // Merge left channel\n      //   //   volumeNodeR.connect(mergerNode, 0, 1); // Merge right channel\n      //   //   // volumeNodeR.connect(mergerNode, 0, 0);\n      //   // }\n\n      //   //   //finally, connect to destination\n      //   //   mergerNode.connect(destination);\n\n      // }\n      // else {      //For normal live tracks\n      //   console.log('***NOT FILTERING: LIVE TRACK***')\n      //    //Pipe source *straight* to destination\n\n\n      //   audioSourceNode.connect(gainNode).connect(destination);\n\n     \n\n      // }\n\n      //     //Attach to the audio element\n      //     audioEl.current.srcObject = destination.stream;\n\n                  //END TODO\n\n\n       // how to do this without audiocontext:\n        audioEl.current.srcObject = new MediaStream([audioTrack]);\n\n     \n\n  \n\n      // for debugging\n      // window.destination=destination; \n      // window.audioTrack=audioTrack;\n      // window.audioEl = audioEl;\n\n      }\n      \n  }, [audioTrack,window.sessionState]);\n\n  function getVideoComponent() {\n    return videoTrack && <video autoPlay muted playsInline ref={videoEl} />;\n\n    \n  }\n\n  function getAudioComponent() {\n    return (\n      !props.isLocalPerson &&\n      audioTrack && <audio autoPlay playsInline ref={audioEl} > </audio>\n    );\n  }\n\n  function getOverlayComponent() {\n    // Show overlay when video is unavailable. Audio may be unavailable too.\n    return videoTrack && (\n      videoUnavailableMessage && (\n        <p className=\"overlay\">\n          {videoUnavailableMessage}\n          {/* {audioUnavailableMessage && (\n            <>\n              <br />\n              {audioUnavailableMessage}\n            </>\n          )} */}\n        </p>\n      )\n    );\n  }\n\n  function getCornerMessageComponent() {\n    // Show corner message when only audio is unavailable.\n    return (\n      !props.disableCornerMessage &&\n      audioUnavailableMessage &&\n      !videoUnavailableMessage && (\n        <p className=\"corner\">{audioUnavailableMessage}</p>\n      )\n    );\n  }\n\n  function getClassNames() {\n    let classNames = 'tile';\n    classNames += props.isLarge ? ' large' : ' small';\n    props.isLocalPerson && (classNames += ' local');\n    return classNames;\n  }\n\n  return (\n    ///TODO change to block : none\n    <div className={getClassNames()} onClick={props.onClick} style={{display: videoTrack ? \"block\" : \"none\"}}  >  \n      <div className=\"background\"/> \n      {getOverlayComponent()}\n      {getVideoComponent()}\n      {videoTrack && getCornerMessageComponent()}\n      {getAudioComponent()}\n    </div>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}