{"ast":null,"code":"var _jsxFileName = \"/Users/arlosb/Documents/GitHub/new react app/test1/src/components/Tile/Tile.js\";\nimport React, { useEffect, useMemo, useRef } from 'react';\nimport './Tile.css';\n\nfunction getTrackUnavailableMessage(kind, trackState) {\n  if (!trackState) return;\n\n  switch (trackState.state) {\n    case 'blocked':\n      if (trackState.blocked.byPermissions) {\n        return `${kind} permission denied`;\n      } else if (trackState.blocked.byDeviceMissing) {\n        return `${kind} device missing`;\n      }\n\n      return `${kind} blocked`;\n\n    case 'off':\n      if (trackState.off.byUser) {\n        return `${kind} muted`;\n      } else if (trackState.off.byBandwidth) {\n        return `${kind} muted to save bandwidth`;\n      }\n\n      return `${kind} off`;\n\n    case 'sendable':\n      return `${kind} not subscribed`;\n\n    case 'loading':\n      return `${kind} loading...`;\n\n    case 'interrupted':\n      return `${kind} interrupted`;\n\n    case 'playable':\n      return null;\n  }\n}\n/**\n * Props\n * - videoTrackState: DailyTrackState?\n * - audioTrackState: DailyTrackState?\n * - isLocalPerson: boolean\n * - isAudioOnly: boolean\n * - isLarge: boolean\n * - disableCornerMessage: boolean\n * - onClick: Function\n * -isScreenShare: boolean\n */\n\n\nexport default function Tile(props) {\n  const videoEl = useRef(null);\n  const audioEl = useRef(null);\n  const videoTrack = useMemo(() => {\n    return props.videoTrackState && props.videoTrackState.state === 'playable' && (props.isLocalPerson || props.videoTrackState.subscribed === true) ? props.videoTrackState.track : null;\n  }, [props.videoTrackState]);\n  const audioTrack = useMemo(() => {\n    if (!props.audioTrackState || !props.audioTrackState.track || props.audioTrackState.state !== 'playable' || props.audioTrackState.subscribed === false) {\n      return null;\n    }\n\n    if (props.disableCornerMessage) {\n      console.log('Is a screen share');\n    }\n\n    if (props.isAudioOnly) {\n      props.audioTrackState.track.isFiltered = true;\n    } else {\n      props.audioTrackState.track.isFiltered = false;\n    }\n\n    if (props.isScreenShare) {\n      console.log('***MADE IT HERE');\n      props.audioTrackState.track.isScreenShare = true;\n    } else {\n      console.log('***NOT A SCREEN SHARE***');\n      props.audioTrackState.track.isScreenShare = false;\n    }\n\n    return props.audioTrackState.track;\n  }, [props.audioTrackState]);\n  const videoUnavailableMessage = useMemo(() => {\n    return getTrackUnavailableMessage('video', props.videoTrackState);\n  }, [props.videoTrackState]);\n  const audioUnavailableMessage = useMemo(() => {\n    return getTrackUnavailableMessage('audio', props.audioTrackState);\n  }, [props.audioTrackState]);\n  /**\n   * When video track changes, update video srcObject\n   */\n\n  useEffect(() => {\n    videoEl.current && (videoEl.current.srcObject = new MediaStream([videoTrack]));\n  }, [videoTrack]);\n  /**\n   * When audio track changes, update audio srcObject\n   */\n\n  useEffect(() => {\n    if (audioEl.current) {\n      //create audio stream\n      let stream = new MediaStream([audioTrack]); //workaround for bug in Chrome, see: https://bit.ly/3ryn1fW\n\n      const mutedAudio = new Audio();\n      mutedAudio.muted = true;\n      mutedAudio.srcObject = stream;\n      mutedAudio.play(); //create Audio Context and destination\n\n      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      let audioSourceNode = audioCtx.createMediaStreamSource(stream);\n      let destination = audioCtx.createMediaStreamDestination(); //gain Node\n\n      let gainNode = audioCtx.createGain(); //panner Node\n\n      var panNode = audioCtx.createStereoPanner(); //splitter\n\n      if (audioTrack.isFiltered) {\n        console.log('**FILTERING LIVE TRACK**'); //adjust nodes\n\n        gainNode.gain.value = 1;\n        panNode.pan.value = 1; //Pipe source through nodes to destination\n\n        audioSourceNode.connect(gainNode).connect(panNode).connect(destination);\n      } else if (audioTrack.isScreenShare) {\n        const splitterNode = new ChannelSplitterNode(audioCtx, {\n          numberOfOutputs: 2\n        });\n        const splitterNodeLL = new ChannelSplitterNode(audioCtx, {\n          numberOfOutputs: 2\n        });\n        const mergerNode = new ChannelMergerNode(audioCtx, {\n          numberOfInputs: 2\n        });\n        const mergerNodeR = new ChannelMergerNode(audioCtx, {\n          numberOfInputs: 2\n        });\n        const volumeNodeL = new GainNode(audioCtx);\n        const volumeNodeR = new GainNode(audioCtx);\n\n        if (window.myRole.includes('Actor')) {\n          //For actors, mix left channel into both sides and keep right channel\n          console.log('**FILTERING: SCREENSHARE AUDIO FOR ACTOR**'); //split audio source into 2 channels: 0 (left), and 1(right)\n\n          audioSourceNode.connect(splitterNode);\n          splitterNode.connect(splitterNodeLL, 0); //split left channel again\n          //mix the left and right into the new right channel\n\n          splitterNodeLL.connect(mergerNodeR, 0, 1); // Merge right of the left channel into right side\n\n          splitterNode.connect(mergerNodeR, 0, 1); // Merge right channel into right side\n          //merge far left and new right\n\n          splitterNodeLL.connect(mergerNode, 0, 0);\n          mergerNodeR.connect(mergerNode, 0, 1); //adjust channels separately\n\n          splitterNode.connect(volumeNodeL, 0); // connect Left channel to its volume node\n\n          splitterNode.connect(volumeNodeR, 1); // connect Right channel to its volume node\n\n          volumeNodeL.gain.value = 1; //set Left volume\n\n          volumeNodeR.gain.value = 1; //set Right volume\n          //merge the channels\n\n          volumeNodeL.connect(mergerNode, 0, 0); // Merge left channel\n\n          volumeNodeR.connect(mergerNode, 0, 1); // Merge right channel\n          // volumeNodeR.connect(mergerNode, 0, 0);\n        } else {\n          //For everyone else , mix left channel into both sides and mute right channel\n          console.log('**FILTERING: SCREENSHARE AUDIO FOR OBSERVER**'); //split audio source into 2 channels: 0 (left), and 1(right)\n\n          audioSourceNode.connect(splitterNode); //adjust channels separately\n\n          splitterNode.connect(volumeNodeL, 0); // connect Left channel to its volume node\n\n          splitterNode.connect(volumeNodeR, 1); // connect Right channel to its volume node\n\n          volumeNodeL.gain.value = 1; //set Left volume\n\n          volumeNodeR.gain.value = 1; //set Right volume\n          //merge the channels\n\n          volumeNodeL.connect(mergerNode, 0, 0); // Merge left channel\n\n          volumeNodeR.connect(mergerNode, 0, 1); // Merge right channel\n          // volumeNodeR.connect(mergerNode, 0, 0);\n        } //finally, connect to destination\n\n\n        mergerNode.connect(destination);\n      } else {\n        //For normal live tracks\n        console.log('***NOT FILTERING: LIVE TRACK***'); //Pipe source *straight* to destination\n\n        audioSourceNode.connect(gainNode).connect(destination); // how to do this without audiocontext:\n        // audioEl.current.srcObject = new MediaStream([audioTrack]);\n      } //Attach to the audio element\n\n\n      audioEl.current.srcObject = destination.stream; // for debugging\n\n      window.destination = destination;\n      window.audioTrack = audioTrack;\n      window.audioEl = audioEl;\n    }\n  }, [audioTrack, window.sessionState]);\n\n  function getVideoComponent() {\n    return videoTrack && /*#__PURE__*/React.createElement(\"video\", {\n      autoPlay: true,\n      muted: true,\n      playsInline: true,\n      ref: videoEl,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 205,\n        columnNumber: 26\n      }\n    });\n  }\n\n  function getAudioComponent() {\n    return !props.isLocalPerson && audioTrack && /*#__PURE__*/React.createElement(\"audio\", {\n      autoPlay: true,\n      playsInline: true,\n      ref: audioEl,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 213,\n        columnNumber: 21\n      }\n    }, \" \");\n  }\n\n  function getOverlayComponent() {\n    // Show overlay when video is unavailable. Audio may be unavailable too.\n    return videoTrack && videoUnavailableMessage && /*#__PURE__*/React.createElement(\"p\", {\n      className: \"overlay\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 221,\n        columnNumber: 9\n      }\n    }, videoUnavailableMessage);\n  }\n\n  function getCornerMessageComponent() {\n    // Show corner message when only audio is unavailable.\n    return !props.disableCornerMessage && audioUnavailableMessage && !videoUnavailableMessage && /*#__PURE__*/React.createElement(\"p\", {\n      className: \"corner\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 240,\n        columnNumber: 9\n      }\n    }, audioUnavailableMessage);\n  }\n\n  function getClassNames() {\n    let classNames = 'tile';\n    classNames += props.isLarge ? ' large' : ' small';\n    props.isLocalPerson && (classNames += ' local');\n    return classNames;\n  }\n\n  return (\n    /*#__PURE__*/\n    ///TODO change to block : none\n    React.createElement(\"div\", {\n      className: getClassNames(),\n      onClick: props.onClick,\n      style: {\n        display: videoTrack ? \"block\" : \"none\"\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 254,\n        columnNumber: 5\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"background\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 255,\n        columnNumber: 7\n      }\n    }), getOverlayComponent(), getVideoComponent(), videoTrack && getCornerMessageComponent(), getAudioComponent())\n  );\n}","map":{"version":3,"sources":["/Users/arlosb/Documents/GitHub/new react app/test1/src/components/Tile/Tile.js"],"names":["React","useEffect","useMemo","useRef","getTrackUnavailableMessage","kind","trackState","state","blocked","byPermissions","byDeviceMissing","off","byUser","byBandwidth","Tile","props","videoEl","audioEl","videoTrack","videoTrackState","isLocalPerson","subscribed","track","audioTrack","audioTrackState","disableCornerMessage","console","log","isAudioOnly","isFiltered","isScreenShare","videoUnavailableMessage","audioUnavailableMessage","current","srcObject","MediaStream","stream","mutedAudio","Audio","muted","play","audioCtx","window","AudioContext","webkitAudioContext","audioSourceNode","createMediaStreamSource","destination","createMediaStreamDestination","gainNode","createGain","panNode","createStereoPanner","gain","value","pan","connect","splitterNode","ChannelSplitterNode","numberOfOutputs","splitterNodeLL","mergerNode","ChannelMergerNode","numberOfInputs","mergerNodeR","volumeNodeL","GainNode","volumeNodeR","myRole","includes","sessionState","getVideoComponent","getAudioComponent","getOverlayComponent","getCornerMessageComponent","getClassNames","classNames","isLarge","onClick","display"],"mappings":"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","sourcesContent":["import React, { useEffect, useMemo, useRef } from 'react';\nimport './Tile.css';\n\nfunction getTrackUnavailableMessage(kind, trackState) {\n  if (!trackState) return;\n  switch (trackState.state) {\n    case 'blocked':\n      if (trackState.blocked.byPermissions) {\n        return `${kind} permission denied`;\n      } else if (trackState.blocked.byDeviceMissing) {\n        return `${kind} device missing`;\n      }\n      return `${kind} blocked`;\n    case 'off':\n      if (trackState.off.byUser) {\n        return `${kind} muted`;\n      } else if (trackState.off.byBandwidth) {\n        return `${kind} muted to save bandwidth`;\n      }\n      return `${kind} off`;\n    case 'sendable':\n      return `${kind} not subscribed`;\n    case 'loading':\n      return `${kind} loading...`;\n    case 'interrupted':\n      return `${kind} interrupted`;\n    case 'playable':\n      return null;\n  }\n}\n\n/**\n * Props\n * - videoTrackState: DailyTrackState?\n * - audioTrackState: DailyTrackState?\n * - isLocalPerson: boolean\n * - isAudioOnly: boolean\n * - isLarge: boolean\n * - disableCornerMessage: boolean\n * - onClick: Function\n * -isScreenShare: boolean\n */\nexport default function Tile(props) {\n  const videoEl = useRef(null);\n  const audioEl = useRef(null);\n\n  const videoTrack = useMemo(() => {\n    return props.videoTrackState && props.videoTrackState.state === 'playable' && (props.isLocalPerson || props.videoTrackState.subscribed === true)\n      ? props.videoTrackState.track\n      : null;\n  }, [props.videoTrackState]);\n\n  const audioTrack = useMemo(() => {\n\n    if (!props.audioTrackState || !props.audioTrackState.track || props.audioTrackState.state !== 'playable' || props.audioTrackState.subscribed === false) \n        {return null;}\n    if(props.disableCornerMessage) {console.log('Is a screen share');}\n    if (props.isAudioOnly) {\n      props.audioTrackState.track.isFiltered=true;\n    } else {props.audioTrackState.track.isFiltered=false;}\n    if (props.isScreenShare) {\n      console.log('***MADE IT HERE');\n      props.audioTrackState.track.isScreenShare=true;\n    } else {console.log('***NOT A SCREEN SHARE***'); props.audioTrackState.track.isScreenShare=false;}\n    return props.audioTrackState.track\n  }, [props.audioTrackState]);\n\n  const videoUnavailableMessage = useMemo(() => {\n    return getTrackUnavailableMessage('video', props.videoTrackState);\n  }, [props.videoTrackState]);\n\n  const audioUnavailableMessage = useMemo(() => {\n    return getTrackUnavailableMessage('audio', props.audioTrackState);\n  }, [props.audioTrackState]);\n\n  /**\n   * When video track changes, update video srcObject\n   */\n  useEffect(() => {\n    videoEl.current &&\n      (videoEl.current.srcObject = new MediaStream([videoTrack]));\n  }, [videoTrack]);\n\n  /**\n   * When audio track changes, update audio srcObject\n   */\n  useEffect(() => {\n    if(audioEl.current) {\n\n      //create audio stream\n      let stream= new MediaStream([audioTrack]);\n\n      //workaround for bug in Chrome, see: https://bit.ly/3ryn1fW\n            const mutedAudio = new Audio(); \n            mutedAudio.muted = true;\n            mutedAudio.srcObject = stream;\n            mutedAudio.play(); \n\n      //create Audio Context and destination\n      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      let audioSourceNode = audioCtx.createMediaStreamSource(stream);\n      let destination = audioCtx.createMediaStreamDestination();\n\n      //gain Node\n      let gainNode = audioCtx.createGain();\n      //panner Node\n      var panNode = audioCtx.createStereoPanner();\n      //splitter\n      \n\n\n      \n      if(audioTrack.isFiltered) {\n        console.log('**FILTERING LIVE TRACK**')\n              //adjust nodes\n              gainNode.gain.value=1;\n              panNode.pan.value=1;      \n              //Pipe source through nodes to destination\n            audioSourceNode.connect(gainNode).connect(panNode).connect(destination);\n        \n      } \n      else if(audioTrack.isScreenShare) {\n        const splitterNode = new ChannelSplitterNode(audioCtx, { numberOfOutputs: 2 });\n        const splitterNodeLL = new ChannelSplitterNode(audioCtx, { numberOfOutputs: 2 });\n        const mergerNode = new ChannelMergerNode(audioCtx, { numberOfInputs: 2 });\n        const mergerNodeR = new ChannelMergerNode(audioCtx, { numberOfInputs: 2 });\n        const volumeNodeL = new GainNode(audioCtx);\n        const volumeNodeR = new GainNode(audioCtx);\n        if(window.myRole.includes('Actor')) {   //For actors, mix left channel into both sides and keep right channel\n          console.log('**FILTERING: SCREENSHARE AUDIO FOR ACTOR**')\n\n\n          //split audio source into 2 channels: 0 (left), and 1(right)\n          audioSourceNode.connect(splitterNode)  \n          splitterNode.connect(splitterNodeLL,0); //split left channel again\n\n          //mix the left and right into the new right channel\n          splitterNodeLL.connect(mergerNodeR, 0, 1); // Merge right of the left channel into right side\n          splitterNode.connect(mergerNodeR, 0, 1); // Merge right channel into right side\n\n          //merge far left and new right\n          splitterNodeLL.connect(mergerNode, 0, 0);\n          mergerNodeR.connect(mergerNode, 0, 1);\n\n\n          //adjust channels separately\n          splitterNode.connect(volumeNodeL, 0); // connect Left channel to its volume node\n          splitterNode.connect(volumeNodeR, 1); // connect Right channel to its volume node\n          volumeNodeL.gain.value = 1; //set Left volume\n          volumeNodeR.gain.value = 1; //set Right volume\n\n          //merge the channels\n          volumeNodeL.connect(mergerNode, 0, 0); // Merge left channel\n          volumeNodeR.connect(mergerNode, 0, 1); // Merge right channel\n          // volumeNodeR.connect(mergerNode, 0, 0);\n          \n\n        } else {        //For everyone else , mix left channel into both sides and mute right channel\n          console.log('**FILTERING: SCREENSHARE AUDIO FOR OBSERVER**')\n\n          //split audio source into 2 channels: 0 (left), and 1(right)\n          audioSourceNode.connect(splitterNode)\n\n\n          //adjust channels separately\n          splitterNode.connect(volumeNodeL, 0); // connect Left channel to its volume node\n          splitterNode.connect(volumeNodeR, 1); // connect Right channel to its volume node\n          volumeNodeL.gain.value = 1; //set Left volume\n          volumeNodeR.gain.value = 1; //set Right volume\n\n          //merge the channels\n          volumeNodeL.connect(mergerNode, 0, 0); // Merge left channel\n          volumeNodeR.connect(mergerNode, 0, 1); // Merge right channel\n          // volumeNodeR.connect(mergerNode, 0, 0);\n        }\n\n          //finally, connect to destination\n          mergerNode.connect(destination);\n\n      }\n      else {      //For normal live tracks\n        console.log('***NOT FILTERING: LIVE TRACK***')\n         //Pipe source *straight* to destination\n        audioSourceNode.connect(gainNode).connect(destination);\n\n        // how to do this without audiocontext:\n        // audioEl.current.srcObject = new MediaStream([audioTrack]);\n      }\n\n     \n\n      //Attach to the audio element\n      audioEl.current.srcObject = destination.stream;\n\n      // for debugging\n      window.destination=destination; \n      window.audioTrack=audioTrack;\n      window.audioEl = audioEl;\n\n      }\n      \n  }, [audioTrack,window.sessionState]);\n\n  function getVideoComponent() {\n    return videoTrack && <video autoPlay muted playsInline ref={videoEl} />;\n\n    \n  }\n\n  function getAudioComponent() {\n    return (\n      !props.isLocalPerson &&\n      audioTrack && <audio autoPlay playsInline ref={audioEl} > </audio>\n    );\n  }\n\n  function getOverlayComponent() {\n    // Show overlay when video is unavailable. Audio may be unavailable too.\n    return videoTrack && (\n      videoUnavailableMessage && (\n        <p className=\"overlay\">\n          {videoUnavailableMessage}\n          {/* {audioUnavailableMessage && (\n            <>\n              <br />\n              {audioUnavailableMessage}\n            </>\n          )} */}\n        </p>\n      )\n    );\n  }\n\n  function getCornerMessageComponent() {\n    // Show corner message when only audio is unavailable.\n    return (\n      !props.disableCornerMessage &&\n      audioUnavailableMessage &&\n      !videoUnavailableMessage && (\n        <p className=\"corner\">{audioUnavailableMessage}</p>\n      )\n    );\n  }\n\n  function getClassNames() {\n    let classNames = 'tile';\n    classNames += props.isLarge ? ' large' : ' small';\n    props.isLocalPerson && (classNames += ' local');\n    return classNames;\n  }\n\n  return (\n    ///TODO change to block : none\n    <div className={getClassNames()} onClick={props.onClick} style={{display: videoTrack ? \"block\" : \"none\"}}>  \n      <div className=\"background\"/> \n      {getOverlayComponent()}\n      {getVideoComponent()}\n      {videoTrack && getCornerMessageComponent()}\n      {getAudioComponent()}\n    </div>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}