{"ast":null,"code":"const crypto = require('crypto');\n\nconst DEFAULT_TOLERANCE = 300; // 5 minutes\n\nconst EXPECTED_SCHEME = 'v1';\n/**\n * Secure compare, from https://github.com/freewil/scmp\n */\n\nfunction secureCompare(_a, _b) {\n  const a = Buffer.from(_a);\n  const b = Buffer.from(_b); // return early here if buffer lengths are not equal since timingSafeEqual\n  // will throw if buffer lengths are not equal\n\n  if (a.length !== b.length) {\n    return false;\n  } // use crypto.timingSafeEqual if available (since Node.js v6.6.0),\n  // otherwise use our own scmp-internal function.\n\n\n  if (crypto.timingSafeEqual) {\n    return crypto.timingSafeEqual(a, b);\n  }\n\n  const len = a.length;\n  let result = 0;\n\n  for (let i = 0; i < len; i += 1) {\n    /* eslint-disable no-bitwise */\n    result |= a[i] ^ b[i];\n  }\n\n  return result === 0;\n}\n\nclass VerifyHeader {\n  static parseHeader(header, scheme = EXPECTED_SCHEME) {\n    if (typeof header !== 'string') {\n      return null;\n    }\n\n    return header.split(',').reduce((accum, item) => {\n      const kv = item.split('=');\n\n      if (kv[0] === 't') {\n        /* eslint-disable no-param-reassign, prefer-destructuring */\n        accum.timestamp = kv[1];\n      }\n\n      if (kv[0] === scheme) {\n        accum.signatures.push(kv[1]);\n      }\n\n      return accum;\n    }, {\n      timestamp: -1,\n      signatures: []\n    });\n  }\n\n  static computeSignature(payload, secret) {\n    return crypto.createHmac('sha256', secret).update(payload, 'utf8').digest('hex');\n  }\n\n  static verify(_payload, _header, secret, tolerance = DEFAULT_TOLERANCE) {\n    const payload = Buffer.isBuffer(_payload) ? _payload.toString('utf8') : _payload;\n    const header = Buffer.isBuffer(_header) ? _header.toString('utf8') : _header;\n    const details = this.parseHeader(header);\n\n    if (!details || details.timestamp === -1) {\n      throw new Error('Unable to extract timestamp and signatures from header');\n    }\n\n    if (!details.signatures.length) {\n      throw new Error('No signatures found with expected scheme');\n    }\n\n    const expectedSignature = this.computeSignature(`${details.timestamp}.${payload}`, secret);\n    const signatureFound = !!details.signatures.filter(sig => secureCompare(sig, expectedSignature)).length;\n\n    if (!signatureFound) {\n      throw new Error('No signatures found matching the expected signature for payload.');\n    }\n\n    const timestampAge = Math.floor(Date.now() / 1000) - details.timestamp;\n\n    if (tolerance > 0 && timestampAge > tolerance) {\n      throw new Error('Timestamp outside the tolerance zone');\n    }\n\n    return true;\n  }\n\n}\n\nmodule.exports = VerifyHeader;","map":{"version":3,"sources":["/Users/arlosb/Documents/GitHub/node_modules/@mux/mux-node/src/webhooks/resources/verify_header.js"],"names":["crypto","require","DEFAULT_TOLERANCE","EXPECTED_SCHEME","secureCompare","_a","_b","a","Buffer","from","b","length","timingSafeEqual","len","result","i","VerifyHeader","parseHeader","header","scheme","split","reduce","accum","item","kv","timestamp","signatures","push","computeSignature","payload","secret","createHmac","update","digest","verify","_payload","_header","tolerance","isBuffer","toString","details","Error","expectedSignature","signatureFound","filter","sig","timestampAge","Math","floor","Date","now","module","exports"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AAEA,MAAMC,iBAAiB,GAAG,GAA1B,C,CAA+B;;AAC/B,MAAMC,eAAe,GAAG,IAAxB;AAEA;AACA;AACA;;AACA,SAASC,aAAT,CAAuBC,EAAvB,EAA2BC,EAA3B,EAA+B;AAC7B,QAAMC,CAAC,GAAGC,MAAM,CAACC,IAAP,CAAYJ,EAAZ,CAAV;AACA,QAAMK,CAAC,GAAGF,MAAM,CAACC,IAAP,CAAYH,EAAZ,CAAV,CAF6B,CAI7B;AACA;;AACA,MAAIC,CAAC,CAACI,MAAF,KAAaD,CAAC,CAACC,MAAnB,EAA2B;AACzB,WAAO,KAAP;AACD,GAR4B,CAU7B;AACA;;;AACA,MAAIX,MAAM,CAACY,eAAX,EAA4B;AAC1B,WAAOZ,MAAM,CAACY,eAAP,CAAuBL,CAAvB,EAA0BG,CAA1B,CAAP;AACD;;AAED,QAAMG,GAAG,GAAGN,CAAC,CAACI,MAAd;AACA,MAAIG,MAAM,GAAG,CAAb;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAApB,EAAyBE,CAAC,IAAI,CAA9B,EAAiC;AAC/B;AACAD,IAAAA,MAAM,IAAIP,CAAC,CAACQ,CAAD,CAAD,GAAOL,CAAC,CAACK,CAAD,CAAlB;AACD;;AACD,SAAOD,MAAM,KAAK,CAAlB;AACD;;AAED,MAAME,YAAN,CAAmB;AACjB,SAAOC,WAAP,CAAmBC,MAAnB,EAA2BC,MAAM,GAAGhB,eAApC,EAAqD;AACnD,QAAI,OAAOe,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,aAAO,IAAP;AACD;;AAED,WAAOA,MAAM,CAACE,KAAP,CAAa,GAAb,EAAkBC,MAAlB,CACL,CAACC,KAAD,EAAQC,IAAR,KAAiB;AACf,YAAMC,EAAE,GAAGD,IAAI,CAACH,KAAL,CAAW,GAAX,CAAX;;AAEA,UAAII,EAAE,CAAC,CAAD,CAAF,KAAU,GAAd,EAAmB;AACjB;AACAF,QAAAA,KAAK,CAACG,SAAN,GAAkBD,EAAE,CAAC,CAAD,CAApB;AACD;;AAED,UAAIA,EAAE,CAAC,CAAD,CAAF,KAAUL,MAAd,EAAsB;AACpBG,QAAAA,KAAK,CAACI,UAAN,CAAiBC,IAAjB,CAAsBH,EAAE,CAAC,CAAD,CAAxB;AACD;;AAED,aAAOF,KAAP;AACD,KAdI,EAeL;AACEG,MAAAA,SAAS,EAAE,CAAC,CADd;AAEEC,MAAAA,UAAU,EAAE;AAFd,KAfK,CAAP;AAoBD;;AAED,SAAOE,gBAAP,CAAwBC,OAAxB,EAAiCC,MAAjC,EAAyC;AACvC,WAAO9B,MAAM,CACV+B,UADI,CACO,QADP,EACiBD,MADjB,EAEJE,MAFI,CAEGH,OAFH,EAEY,MAFZ,EAGJI,MAHI,CAGG,KAHH,CAAP;AAID;;AAED,SAAOC,MAAP,CAAcC,QAAd,EAAwBC,OAAxB,EAAiCN,MAAjC,EAAyCO,SAAS,GAAGnC,iBAArD,EAAwE;AACtE,UAAM2B,OAAO,GAAGrB,MAAM,CAAC8B,QAAP,CAAgBH,QAAhB,IACZA,QAAQ,CAACI,QAAT,CAAkB,MAAlB,CADY,GAEZJ,QAFJ;AAGA,UAAMjB,MAAM,GAAGV,MAAM,CAAC8B,QAAP,CAAgBF,OAAhB,IACXA,OAAO,CAACG,QAAR,CAAiB,MAAjB,CADW,GAEXH,OAFJ;AAIA,UAAMI,OAAO,GAAG,KAAKvB,WAAL,CAAiBC,MAAjB,CAAhB;;AAEA,QAAI,CAACsB,OAAD,IAAYA,OAAO,CAACf,SAAR,KAAsB,CAAC,CAAvC,EAA0C;AACxC,YAAM,IAAIgB,KAAJ,CAAU,wDAAV,CAAN;AACD;;AAED,QAAI,CAACD,OAAO,CAACd,UAAR,CAAmBf,MAAxB,EAAgC;AAC9B,YAAM,IAAI8B,KAAJ,CAAU,0CAAV,CAAN;AACD;;AAED,UAAMC,iBAAiB,GAAG,KAAKd,gBAAL,CACvB,GAAEY,OAAO,CAACf,SAAU,IAAGI,OAAQ,EADR,EAExBC,MAFwB,CAA1B;AAKA,UAAMa,cAAc,GAAG,CAAC,CAACH,OAAO,CAACd,UAAR,CAAmBkB,MAAnB,CAA0BC,GAAG,IACpDzC,aAAa,CAACyC,GAAD,EAAMH,iBAAN,CADU,EAEvB/B,MAFF;;AAIA,QAAI,CAACgC,cAAL,EAAqB;AACnB,YAAM,IAAIF,KAAJ,CACJ,kEADI,CAAN;AAGD;;AAED,UAAMK,YAAY,GAAGC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,IAAgCV,OAAO,CAACf,SAA7D;;AAEA,QAAIY,SAAS,GAAG,CAAZ,IAAiBS,YAAY,GAAGT,SAApC,EAA+C;AAC7C,YAAM,IAAII,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAED,WAAO,IAAP;AACD;;AA3EgB;;AA8EnBU,MAAM,CAACC,OAAP,GAAiBpC,YAAjB","sourcesContent":["const crypto = require('crypto');\n\nconst DEFAULT_TOLERANCE = 300; // 5 minutes\nconst EXPECTED_SCHEME = 'v1';\n\n/**\n * Secure compare, from https://github.com/freewil/scmp\n */\nfunction secureCompare(_a, _b) {\n  const a = Buffer.from(_a);\n  const b = Buffer.from(_b);\n\n  // return early here if buffer lengths are not equal since timingSafeEqual\n  // will throw if buffer lengths are not equal\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  // use crypto.timingSafeEqual if available (since Node.js v6.6.0),\n  // otherwise use our own scmp-internal function.\n  if (crypto.timingSafeEqual) {\n    return crypto.timingSafeEqual(a, b);\n  }\n\n  const len = a.length;\n  let result = 0;\n\n  for (let i = 0; i < len; i += 1) {\n    /* eslint-disable no-bitwise */\n    result |= a[i] ^ b[i];\n  }\n  return result === 0;\n}\n\nclass VerifyHeader {\n  static parseHeader(header, scheme = EXPECTED_SCHEME) {\n    if (typeof header !== 'string') {\n      return null;\n    }\n\n    return header.split(',').reduce(\n      (accum, item) => {\n        const kv = item.split('=');\n\n        if (kv[0] === 't') {\n          /* eslint-disable no-param-reassign, prefer-destructuring */\n          accum.timestamp = kv[1];\n        }\n\n        if (kv[0] === scheme) {\n          accum.signatures.push(kv[1]);\n        }\n\n        return accum;\n      },\n      {\n        timestamp: -1,\n        signatures: [],\n      }\n    );\n  }\n\n  static computeSignature(payload, secret) {\n    return crypto\n      .createHmac('sha256', secret)\n      .update(payload, 'utf8')\n      .digest('hex');\n  }\n\n  static verify(_payload, _header, secret, tolerance = DEFAULT_TOLERANCE) {\n    const payload = Buffer.isBuffer(_payload)\n      ? _payload.toString('utf8')\n      : _payload;\n    const header = Buffer.isBuffer(_header)\n      ? _header.toString('utf8')\n      : _header;\n\n    const details = this.parseHeader(header);\n\n    if (!details || details.timestamp === -1) {\n      throw new Error('Unable to extract timestamp and signatures from header');\n    }\n\n    if (!details.signatures.length) {\n      throw new Error('No signatures found with expected scheme');\n    }\n\n    const expectedSignature = this.computeSignature(\n      `${details.timestamp}.${payload}`,\n      secret\n    );\n\n    const signatureFound = !!details.signatures.filter(sig =>\n      secureCompare(sig, expectedSignature)\n    ).length;\n\n    if (!signatureFound) {\n      throw new Error(\n        'No signatures found matching the expected signature for payload.'\n      );\n    }\n\n    const timestampAge = Math.floor(Date.now() / 1000) - details.timestamp;\n\n    if (tolerance > 0 && timestampAge > tolerance) {\n      throw new Error('Timestamp outside the tolerance zone');\n    }\n\n    return true;\n  }\n}\n\nmodule.exports = VerifyHeader;\n"]},"metadata":{},"sourceType":"script"}