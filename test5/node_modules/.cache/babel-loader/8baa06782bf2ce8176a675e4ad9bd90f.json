{"ast":null,"code":"var _classCallCheck = require(\"/Users/arlosb/Documents/GitHub/new react app/test5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/arlosb/Documents/GitHub/new react app/test5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar crypto = require('crypto');\n\nvar DEFAULT_TOLERANCE = 300; // 5 minutes\n\nvar EXPECTED_SCHEME = 'v1';\n/**\n * Secure compare, from https://github.com/freewil/scmp\n */\n\nfunction secureCompare(_a, _b) {\n  var a = Buffer.from(_a);\n  var b = Buffer.from(_b); // return early here if buffer lengths are not equal since timingSafeEqual\n  // will throw if buffer lengths are not equal\n\n  if (a.length !== b.length) {\n    return false;\n  } // use crypto.timingSafeEqual if available (since Node.js v6.6.0),\n  // otherwise use our own scmp-internal function.\n\n\n  if (crypto.timingSafeEqual) {\n    return crypto.timingSafeEqual(a, b);\n  }\n\n  var len = a.length;\n  var result = 0;\n\n  for (var i = 0; i < len; i += 1) {\n    /* eslint-disable no-bitwise */\n    result |= a[i] ^ b[i];\n  }\n\n  return result === 0;\n}\n\nvar VerifyHeader = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function VerifyHeader() {\n    _classCallCheck(this, VerifyHeader);\n  }\n\n  _createClass(VerifyHeader, null, [{\n    key: \"parseHeader\",\n    value: function parseHeader(header) {\n      var scheme = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EXPECTED_SCHEME;\n\n      if (typeof header !== 'string') {\n        return null;\n      }\n\n      return header.split(',').reduce(function (accum, item) {\n        var kv = item.split('=');\n\n        if (kv[0] === 't') {\n          /* eslint-disable no-param-reassign, prefer-destructuring */\n          accum.timestamp = kv[1];\n        }\n\n        if (kv[0] === scheme) {\n          accum.signatures.push(kv[1]);\n        }\n\n        return accum;\n      }, {\n        timestamp: -1,\n        signatures: []\n      });\n    }\n  }, {\n    key: \"computeSignature\",\n    value: function computeSignature(payload, secret) {\n      return crypto.createHmac('sha256', secret).update(payload, 'utf8').digest('hex');\n    }\n  }, {\n    key: \"verify\",\n    value: function verify(_payload, _header, secret) {\n      var tolerance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_TOLERANCE;\n      var payload = Buffer.isBuffer(_payload) ? _payload.toString('utf8') : _payload;\n      var header = Buffer.isBuffer(_header) ? _header.toString('utf8') : _header;\n      var details = this.parseHeader(header);\n\n      if (!details || details.timestamp === -1) {\n        throw new Error('Unable to extract timestamp and signatures from header');\n      }\n\n      if (!details.signatures.length) {\n        throw new Error('No signatures found with expected scheme');\n      }\n\n      var expectedSignature = this.computeSignature(\"\".concat(details.timestamp, \".\").concat(payload), secret);\n      var signatureFound = !!details.signatures.filter(function (sig) {\n        return secureCompare(sig, expectedSignature);\n      }).length;\n\n      if (!signatureFound) {\n        throw new Error('No signatures found matching the expected signature for payload.');\n      }\n\n      var timestampAge = Math.floor(Date.now() / 1000) - details.timestamp;\n\n      if (tolerance > 0 && timestampAge > tolerance) {\n        throw new Error('Timestamp outside the tolerance zone');\n      }\n\n      return true;\n    }\n  }]);\n\n  return VerifyHeader;\n}();\n\nmodule.exports = VerifyHeader;","map":null,"metadata":{},"sourceType":"script"}