{"ast":null,"code":"var _jsxFileName = \"/Users/arlosb/Documents/GitHub/new react app/test5/src/components/Livestorm/Tile/Tile.js\";\nimport React, { useEffect, useMemo, useRef, useState } from 'react';\nimport './Tile.css';\n\nfunction useForceUpdate() {\n  const [value, setValue] = useState(0); // integer state\n\n  return () => setValue(value => value + 1); // update the state to force render\n}\n\nfunction getTrackUnavailableMessage(kind, trackState) {\n  if (!trackState) return;\n\n  switch (trackState.state) {\n    case 'blocked':\n      if (trackState.blocked.byPermissions) {\n        return `${kind} permission denied`;\n      } else if (trackState.blocked.byDeviceMissing) {\n        return `${kind} device missing`;\n      }\n\n      return `${kind} blocked`;\n\n    case 'off':\n      if (trackState.off.byUser) {\n        return `${kind} muted`;\n      } else if (trackState.off.byBandwidth) {\n        return `${kind} muted to save bandwidth`;\n      }\n\n      return `${kind} off`;\n\n    case 'sendable':\n      return `${kind} not subscribed`;\n\n    case 'loading':\n      return `${kind} loading...`;\n\n    case 'interrupted':\n      return `${kind} interrupted`;\n\n    case 'playable':\n      return null;\n  }\n}\n/**\n * Props\n * - videoTrackState: DailyTrackState?\n * - audioTrackState: DailyTrackState?\n * - isLocalPerson: boolean\n * - isAudioOnly: boolean\n * - isLarge: boolean\n * - disableCornerMessage: boolean\n * - onClick: Function\n * -isScreenShare: boolean\n */\n\n\nexport default function Tile(props) {\n  const videoEl = useRef(null);\n  const audioEl = useRef(null);\n  const forceUpdate = useForceUpdate(); // window.updateTile = () => {\n  //   forceUpdate();\n  // }\n\n  const videoTrack = useMemo(() => {\n    return props.videoTrackState && props.videoTrackState.state === 'playable' && (props.isLocalPerson || props.videoTrackState.subscribed === true || props.isScreenShare) ///that last bit makes you see your own screenshare\n    ? props.videoTrackState.track : null;\n  }, [props.videoTrackState]);\n  const subscribed = useMemo(() => {\n    //should be considered \"subscribed\" if video track is non-local + subscribed (even if the cam is off, to render black background), OR if it's local and cam is on\n    return props.videoTrackState && (props.isLocalPerson && props.videoTrackState.state === 'playable' || props.videoTrackState.subscribed) || props.isScreenShare; ///that last bit makes you see your own screenshare\n  }, [props.videoTrackState]);\n  const audioTrack = useMemo(() => {\n    if (!props.audioTrackState || !props.audioTrackState.track || props.audioTrackState.state !== 'playable' || props.audioTrackState.subscribed === false) {\n      return null;\n    } // if(props.disableCornerMessage) {console.log('Is a screen share');}\n\n\n    if (props.isAudioOnly) {\n      props.audioTrackState.track.isFiltered = true;\n    } else {\n      props.audioTrackState.track.isFiltered = false;\n    }\n\n    if (props.isScreenShare) {\n      props.audioTrackState.track.isScreenShare = true;\n    } else {\n      props.audioTrackState.track.isScreenShare = false;\n    }\n\n    return props.audioTrackState.track;\n  }, [props.audioTrackState]);\n  const videoUnavailableMessage = useMemo(() => {\n    return getTrackUnavailableMessage('video', props.videoTrackState);\n  }, [props.videoTrackState]);\n  const audioUnavailableMessage = useMemo(() => {\n    return getTrackUnavailableMessage('audio', props.audioTrackState);\n  }, [props.audioTrackState]);\n  /**\n   * When video track changes, update video srcObject\n   */\n\n  useEffect(() => {\n    videoEl.current && (videoEl.current.srcObject = new MediaStream([videoTrack]));\n  }, [videoTrack]);\n  /**\n   * When audio track changes, update audio srcObject\n   */\n\n  useEffect(() => {\n    if (audioEl.current) {\n      ///////////////TODO START TEMP DELETED PORTION\n      if (audioTrack.isFiltered) {\n        console.log('**FILTERING LIVE TRACK**'); ///******audiocontext creation section///\n        //create audio stream\n\n        window.stream = new MediaStream([audioTrack]); //workaround for bug in Chrome, see: https://bit.ly/3ryn1fW\n\n        window.mutedAudio = window.mutedAudio || new Audio();\n        window.mutedAudio.muted = true;\n\n        if (!window.mutedAudio.srcObject) {\n          window.mutedAudio.srcObject = window.stream;\n        }\n\n        window.mutedAudio.paused && window.mutedAudio.play(); //create Audio Context and destination\n\n        window.audioCtx = window.audioCtx || new (window.AudioContext || window.webkitAudioContext)();\n        window.audioSourceNode = window.audioCtx.createMediaStreamSource(window.stream);\n\n        if (typeof window.destination == 'undefined') {\n          window.destination = window.audioCtx.createMediaStreamDestination();\n        } //gain Node\n\n\n        if (typeof window.gainNode == 'undefined') {\n          window.gainNode = window.audioCtx.createGain();\n        } //panner Node\n\n\n        if (typeof window.panNode == 'undefined') {\n          window.panNode = window.audioCtx.createStereoPanner();\n        } //*****end audiocontext creation section\n        //adjust nodes\n\n\n        window.gainNode.gain.value = 1;\n        window.panNode.pan.value = 1; //Pipe source through nodes to destination\n\n        window.audioSourceNode.connect(window.gainNode).connect(window.panNode).connect(window.destination); //Attach to the audio element\n\n        audioEl.current.srcObject = window.destination.stream;\n      } else if (audioTrack.isScreenShare) {\n        //for everyone, just piping the received audio (which was the left channel of the original video) straight through\n        console.log('***GETTING SCREENSHARE AUDIO'); ///***With audiocontext:  */\n        // window.audioSourceNode.connect(destination);\n        ///without Audiocontext:////\n\n        audioEl.current.srcObject = new MediaStream([audioTrack]);\n      } else {\n        //For normal live tracks\n        console.log('***NOT FILTERING: LIVE TRACK***'); //Pipe source *straight* to destination, through audiocontext\n        // window.audioSourceNode.connect(gainNode).connect(destination);\n        //without audiocontext\n\n        audioEl.current.srcObject = new MediaStream([audioTrack]);\n      } ///END TODO TEMP DELETED PORTION\n      //when above is deleted:\n      //  audioEl.current.srcObject = new MediaStream([audioTrack]);\n      // for debugging\n      // window.destination=destination; \n      // window.audioTrack=audioTrack;\n      // window.audioEl = audioEl;\n\n    }\n  }, [audioTrack, window.sessionState]);\n\n  function getVideoComponent() {\n    return videoTrack && /*#__PURE__*/React.createElement(\"video\", {\n      autoPlay: true,\n      muted: true,\n      playsInline: true,\n      ref: videoEl,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 194,\n        columnNumber: 26\n      }\n    });\n  }\n\n  function getAudioComponent() {\n    return !props.isLocalPerson && audioTrack && /*#__PURE__*/React.createElement(\"audio\", {\n      autoPlay: true,\n      playsInline: true,\n      ref: audioEl,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 201,\n        columnNumber: 21\n      }\n    }, \" \");\n  }\n\n  function getOverlayComponent() {\n    // Show overlay when video is unavailable. Audio may be unavailable too.\n    return videoTrack && videoUnavailableMessage && /*#__PURE__*/React.createElement(\"p\", {\n      className: \"overlay\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 209,\n        columnNumber: 9\n      }\n    }, videoUnavailableMessage);\n  }\n\n  function getCornerMessageComponent() {\n    // Show corner message when only audio is unavailable.\n    return !props.disableCornerMessage && audioUnavailableMessage && !videoUnavailableMessage && /*#__PURE__*/React.createElement(\"p\", {\n      className: \"corner\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 228,\n        columnNumber: 9\n      }\n    }, audioUnavailableMessage);\n  }\n\n  function getClassNames() {\n    let classNames = 'tile';\n    classNames += props.isLarge ? ' large' : ' small';\n    props.isLocalPerson && (classNames += ' local');\n    props.isScreenShare && (classNames += ' screen-share');\n    return classNames;\n  }\n\n  return (\n    /*#__PURE__*/\n    ///TODO change to block : none (otherwise will show black background even when not subscribed)\n    React.createElement(\"div\", {\n      className: getClassNames(),\n      onClick: props.onClick,\n      style: {\n        display: subscribed ? \"block\" : \"none\"\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 244,\n        columnNumber: 5\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"background\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 245,\n        columnNumber: 7\n      }\n    }), getOverlayComponent(), getVideoComponent(), videoTrack && getCornerMessageComponent(), getAudioComponent())\n  );\n}","map":{"version":3,"sources":["/Users/arlosb/Documents/GitHub/new react app/test5/src/components/Livestorm/Tile/Tile.js"],"names":["React","useEffect","useMemo","useRef","useState","useForceUpdate","value","setValue","getTrackUnavailableMessage","kind","trackState","state","blocked","byPermissions","byDeviceMissing","off","byUser","byBandwidth","Tile","props","videoEl","audioEl","forceUpdate","videoTrack","videoTrackState","isLocalPerson","subscribed","isScreenShare","track","audioTrack","audioTrackState","isAudioOnly","isFiltered","videoUnavailableMessage","audioUnavailableMessage","current","srcObject","MediaStream","console","log","window","stream","mutedAudio","Audio","muted","paused","play","audioCtx","AudioContext","webkitAudioContext","audioSourceNode","createMediaStreamSource","destination","createMediaStreamDestination","gainNode","createGain","panNode","createStereoPanner","gain","pan","connect","sessionState","getVideoComponent","getAudioComponent","getOverlayComponent","getCornerMessageComponent","disableCornerMessage","getClassNames","classNames","isLarge","onClick","display"],"mappings":"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","sourcesContent":["import React, { useEffect, useMemo, useRef, useState } from 'react';\nimport './Tile.css';\nfunction useForceUpdate(){\n  const [value, setValue] = useState(0); // integer state\n  return () => setValue(value => value + 1); // update the state to force render\n}\n\nfunction getTrackUnavailableMessage(kind, trackState) {\n  if (!trackState) return;\n  switch (trackState.state) {\n    case 'blocked':\n      if (trackState.blocked.byPermissions) {\n        return `${kind} permission denied`;\n      } else if (trackState.blocked.byDeviceMissing) {\n        return `${kind} device missing`;\n      }\n      return `${kind} blocked`;\n    case 'off':\n      if (trackState.off.byUser) {\n        return `${kind} muted`;\n      } else if (trackState.off.byBandwidth) {\n        return `${kind} muted to save bandwidth`;\n      }\n      return `${kind} off`;\n    case 'sendable':\n      return `${kind} not subscribed`;\n    case 'loading':\n      return `${kind} loading...`;\n    case 'interrupted':\n      return `${kind} interrupted`;\n    case 'playable':\n      return null;\n  }\n}\n\n/**\n * Props\n * - videoTrackState: DailyTrackState?\n * - audioTrackState: DailyTrackState?\n * - isLocalPerson: boolean\n * - isAudioOnly: boolean\n * - isLarge: boolean\n * - disableCornerMessage: boolean\n * - onClick: Function\n * -isScreenShare: boolean\n */\nexport default function Tile(props) {\n  const videoEl = useRef(null);\n  const audioEl = useRef(null);\n  const forceUpdate = useForceUpdate();\n\n  // window.updateTile = () => {\n  //   forceUpdate();\n  // }\n\n  const videoTrack = useMemo(() => {\n    return props.videoTrackState && props.videoTrackState.state === 'playable' && ((props.isLocalPerson || props.videoTrackState.subscribed === true) || props.isScreenShare) ///that last bit makes you see your own screenshare\n      ? props.videoTrackState.track\n      : null;\n  }, [props.videoTrackState]);\n\n  const subscribed = useMemo(() => {\n    //should be considered \"subscribed\" if video track is non-local + subscribed (even if the cam is off, to render black background), OR if it's local and cam is on\n    return props.videoTrackState && ( (props.isLocalPerson && props.videoTrackState.state === 'playable') || props.videoTrackState.subscribed) || props.isScreenShare; ///that last bit makes you see your own screenshare\n  }, [props.videoTrackState]);\n\n  const audioTrack = useMemo(() => {\n\n    if (!props.audioTrackState || !props.audioTrackState.track || props.audioTrackState.state !== 'playable' || props.audioTrackState.subscribed === false) \n        {return null;}\n    // if(props.disableCornerMessage) {console.log('Is a screen share');}\n    if (props.isAudioOnly) {\n      props.audioTrackState.track.isFiltered=true;\n    } else {props.audioTrackState.track.isFiltered=false;}\n    if (props.isScreenShare) {\n      props.audioTrackState.track.isScreenShare=true;\n    } else {props.audioTrackState.track.isScreenShare=false;}\n    return props.audioTrackState.track\n  }, [props.audioTrackState]);\n\n  const videoUnavailableMessage = useMemo(() => {\n    return getTrackUnavailableMessage('video', props.videoTrackState);\n  }, [props.videoTrackState]);\n\n  const audioUnavailableMessage = useMemo(() => {\n    return getTrackUnavailableMessage('audio', props.audioTrackState);\n  }, [props.audioTrackState]);\n\n  /**\n   * When video track changes, update video srcObject\n   */\n  useEffect(() => {\n    videoEl.current &&\n      (videoEl.current.srcObject = new MediaStream([videoTrack]));\n  }, [videoTrack]);\n\n  /**\n   * When audio track changes, update audio srcObject\n   */\n  useEffect(() => {\n    if(audioEl.current) {\n\n\n     ///////////////TODO START TEMP DELETED PORTION\n\n\n\n      if(audioTrack.isFiltered) {\n        console.log('**FILTERING LIVE TRACK**')\n\n          ///******audiocontext creation section///\n\n          //create audio stream\n          window.stream= new MediaStream([audioTrack]);\n\n          //workaround for bug in Chrome, see: https://bit.ly/3ryn1fW\n                window.mutedAudio = window.mutedAudio || new Audio(); \n                window.mutedAudio.muted = true;\n                if(!window.mutedAudio.srcObject) {window.mutedAudio.srcObject = window.stream;}\n                window.mutedAudio.paused && window.mutedAudio.play(); \n\n          //create Audio Context and destination\n          window.audioCtx = window.audioCtx || new (window.AudioContext || window.webkitAudioContext)();\n         window.audioSourceNode = window.audioCtx.createMediaStreamSource(window.stream);\n          if (typeof(window.destination)=='undefined'){window.destination = window.audioCtx.createMediaStreamDestination();}\n\n          //gain Node\n          if (typeof(window.gainNode)=='undefined') {window.gainNode = window.audioCtx.createGain();}\n          //panner Node\n          if (typeof(window.panNode)=='undefined') {window.panNode = window.audioCtx.createStereoPanner()}\n\n\n          //*****end audiocontext creation section\n\n\n              //adjust nodes\n              window.gainNode.gain.value=1;\n              window.panNode.pan.value=1;      \n              //Pipe source through nodes to destination\n            window.audioSourceNode.connect(window.gainNode).connect(window.panNode).connect(window.destination);\n\n            //Attach to the audio element\n          audioEl.current.srcObject = window.destination.stream;\n        \n      } \n      else if(audioTrack.isScreenShare) {\n\n        //for everyone, just piping the received audio (which was the left channel of the original video) straight through\n        console.log('***GETTING SCREENSHARE AUDIO')\n        ///***With audiocontext:  */\n        // window.audioSourceNode.connect(destination);\n\n\n        ///without Audiocontext:////\n        audioEl.current.srcObject = new MediaStream([audioTrack]);\n\n\n\n      }\n      else {      //For normal live tracks\n        console.log('***NOT FILTERING: LIVE TRACK***')\n\n         //Pipe source *straight* to destination, through audiocontext\n        // window.audioSourceNode.connect(gainNode).connect(destination);\n\n        //without audiocontext\n        audioEl.current.srcObject = new MediaStream([audioTrack]);\n\n      }\n\n      ///END TODO TEMP DELETED PORTION\n\n\n       //when above is deleted:\n      //  audioEl.current.srcObject = new MediaStream([audioTrack]);\n\n          \n\n\n     \n\n  \n\n      // for debugging\n      // window.destination=destination; \n      // window.audioTrack=audioTrack;\n      // window.audioEl = audioEl;\n\n      }\n      \n  }, [audioTrack,window.sessionState]);\n\n  function getVideoComponent() {\n    return videoTrack && <video autoPlay muted playsInline ref={videoEl} />;\n\n  }\n\n  function getAudioComponent() {\n    return (\n      !props.isLocalPerson &&\n      audioTrack && <audio autoPlay playsInline ref={audioEl} > </audio>\n    );\n  }\n\n  function getOverlayComponent() {\n    // Show overlay when video is unavailable. Audio may be unavailable too.\n    return videoTrack && (\n      videoUnavailableMessage && (\n        <p className=\"overlay\">\n          {videoUnavailableMessage}\n          {/* {audioUnavailableMessage && (\n            <>\n              <br />\n              {audioUnavailableMessage}\n            </>\n          )} */}\n        </p>\n      )\n    );\n  }\n\n  function getCornerMessageComponent() {\n    // Show corner message when only audio is unavailable.\n    return (\n      !props.disableCornerMessage &&\n      audioUnavailableMessage &&\n      !videoUnavailableMessage && (\n        <p className=\"corner\">{audioUnavailableMessage}</p>\n      )\n    );\n  }\n\n  function getClassNames() {\n    let classNames = 'tile';\n    classNames += props.isLarge ? ' large' : ' small';\n    props.isLocalPerson && (classNames += ' local');\n    props.isScreenShare && (classNames += ' screen-share');\n    return classNames;\n  }\n\n  return (\n    ///TODO change to block : none (otherwise will show black background even when not subscribed)\n\n    <div className={getClassNames()} onClick={props.onClick} style={{display: subscribed ? \"block\" : \"none\"}}>   \n      <div className=\"background\"/> \n      {getOverlayComponent()}\n      {getVideoComponent()}\n      {videoTrack && getCornerMessageComponent()}\n      {getAudioComponent()}\n    </div>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}