{"ast":null,"code":"var _jsxFileName = \"/Users/arlosb/Documents/GitHub/new react app/test4/src/components/Call/Call.js\";\nimport React, { useEffect, useContext, useReducer, useCallback, useState } from 'react';\nimport './Call.css';\nimport Tile from '../Tile/Tile';\nimport CallObjectContext from '../../CallObjectContext';\nimport MyContext from '../../MyContext';\nimport SessionStateContext from '../../SessionStateContext';\nimport CallMessage from '../CallMessage/CallMessage';\nimport { initialCallState, CLICK_ALLOW_TIMEOUT, PARTICIPANTS_CHANGE, CAM_OR_MIC_ERROR, FATAL_ERROR, callReducer, isLocal, isScreenShare, containsScreenShare, getMessage } from './callState';\nimport { logDailyEvent } from '../../logUtils';\nimport useSetSubscriptions from '../../hooks/setSubscriptions';\n\nfunction useForceUpdate() {\n  const [value, setValue] = useState(0); // integer state\n\n  return () => setValue(value => value + 1); // update the state to force render\n}\n\nexport default function Call() {\n  useSetSubscriptions();\n  const callObject = useContext(CallObjectContext);\n  const {\n    session\n  } = useContext(SessionStateContext);\n  const [sessionState, setSessionState] = session;\n  const [callState, dispatch] = useReducer(callReducer, initialCallState);\n  const forceUpdate = useForceUpdate();\n  const {\n    myStateArray,\n    setName,\n    setRole,\n    setUserList,\n    setViewMode,\n    setCamOn,\n    setMicOnAtSessionStart,\n    setAdminPresent,\n    setAmAdmin,\n    setNumber\n  } = useContext(MyContext);\n  const [myState, setMyState] = myStateArray;\n\n  window.updateCall = () => {\n    forceUpdate();\n  };\n  /**\n    * Set default viewmode when session begins or my role changes\n    */\n\n\n  useEffect(() => {\n    if (sessionState.isActive) {\n      if (sessionState.roleOf.Shadow1) {\n        setViewMode('Shadow1');\n      } else if (sessionState.roleOf.Shadow2) //fallbacks in case shadow1 is not assigned\n        {\n          setViewMode('Shadow2');\n        } else if (sessionState.roleOf.Shadow3) {\n        setViewMode('Shadow3');\n      } else if (sessionState.roleOf.Shadow4) {\n        setViewMode('Shadow4');\n      } else {\n        setViewMode('Seller');\n      }\n    } else {\n      setViewMode(null);\n    }\n  }, [sessionState.isActive, myState.role]);\n  /**\n  * Update my role according to sessionState changes\n  */\n\n  useEffect(() => {\n    let myNewRole = 'Attendee'; //default, if no role assigned\n\n    for (const key in sessionState.roleOf) {\n      if (sessionState.roleOf[key] == myState.name) {\n        myNewRole = key;\n      }\n    }\n\n    if (myNewRole !== myState.role) {\n      setRole(myNewRole);\n\n      if (myNewRole.includes('1')) {\n        setNumber(1);\n      } else if (myNewRole.includes('2')) {\n        setNumber(2);\n      }\n    }\n  }, [sessionState.roleOf]);\n\n  function updateUserList() {\n    let userListIncludesAdmin = false;\n    setAdminPresent(false);\n    let ps = callObject.participants();\n    let workingUserList = {\n      names: [],\n      sessionIdFor: {}\n    };\n\n    for (const p in ps) {\n      let thisUserName = ps[p].user_name;\n      let thisSessionId = ps[p].session_id;\n      workingUserList.names.push(thisUserName); //add each user_name with its sessionID to UserList\n\n      workingUserList.sessionIdFor[thisUserName] = thisSessionId;\n\n      if (thisUserName.includes('_Admin') && p !== 'local') {\n        userListIncludesAdmin = true;\n      }\n    }\n\n    ;\n    userListIncludesAdmin ? console.log('Admin IS present') : console.log('Admin IS NOT present');\n    setAdminPresent(userListIncludesAdmin);\n    workingUserList.names.sort(); //alphebetize that list \n\n    console.log(`now the userList is: ${workingUserList.names}`); //print userList\n\n    setUserList(workingUserList);\n  }\n  /**\n   * Start listening for participant changes, when the callObject is set.\n   */\n\n\n  useEffect(() => {\n    if (!callObject) return;\n    const events = ['participant-joined', 'participant-updated', 'participant-left', 'joined-meeting'];\n\n    function handleNewParticipantsState(e) {\n      e && logDailyEvent(e);\n      dispatch({\n        type: PARTICIPANTS_CHANGE,\n        participants: callObject.participants()\n      });\n\n      if (e && e.action != 'participant-updated') {\n        let thisUserName = e.participant.user_name;\n\n        if (e.action == \"participant-joined\" || e.action == \"participant-left\") {\n          window.event = e;\n          const getUserName = setInterval( //necessary only because emitted event doesn't include participant's name at first :/\n          () => {\n            if (thisUserName) {\n              updateUserList();\n              clearInterval(getUserName);\n            }\n          }, 100);\n        }\n      }\n    } // Use initial state\n\n\n    handleNewParticipantsState(); // Listen for changes in state\n\n    for (const event of events) {\n      callObject.on(event, handleNewParticipantsState);\n    } // Stop listening for changes in state\n\n\n    return function cleanup() {\n      for (const event of events) {\n        callObject.off(event, handleNewParticipantsState);\n      }\n    };\n  }, [callObject]);\n  /**\n   * Attach userList to window for debugging\n   */\n\n  useEffect(() => {\n    window.userList = myState.userList;\n  }, [myState.userList]);\n  /**\n    * Attach sessionState to window for debugging\n    */\n\n  useEffect(() => {\n    window.sessionState = sessionState;\n  }, [sessionState]);\n  /**\n    * Attach myState to window for debugging\n    */\n\n  useEffect(() => {\n    window.myState = myState;\n  }, [myState]);\n  /**\n   * Start listening for call errors, when the callObject is set.\n   */\n\n  useEffect(() => {\n    if (!callObject) return;\n\n    function handleCameraErrorEvent(event) {\n      logDailyEvent(event);\n      dispatch({\n        type: CAM_OR_MIC_ERROR,\n        message: event && event.errorMsg && event.errorMsg.errorMsg || 'Unknown'\n      });\n    } // We're making an assumption here: there is no camera error when callObject\n    // is first assigned.\n\n\n    callObject.on('camera-error', handleCameraErrorEvent);\n    return function cleanup() {\n      callObject.off('camera-error', handleCameraErrorEvent);\n    };\n  }, [callObject]);\n  /**\n   * Start listening for fatal errors, when the callObject is set.\n   */\n\n  useEffect(() => {\n    if (!callObject) return;\n\n    function handleErrorEvent(e) {\n      logDailyEvent(e);\n      dispatch({\n        type: FATAL_ERROR,\n        message: e && e.errorMsg || 'Unknown'\n      });\n    } // We're making an assumption here: there is no error when callObject is\n    // first assigned.\n\n\n    callObject.on('error', handleErrorEvent);\n    return function cleanup() {\n      callObject.off('error', handleErrorEvent);\n    };\n  }, [callObject]);\n  /**\n   * Start a timer to show the \"click allow\" message, when the component mounts.\n   */\n\n  useEffect(() => {\n    const t = setTimeout(() => {\n      dispatch({\n        type: CLICK_ALLOW_TIMEOUT\n      });\n    }, 2500);\n    return function cleanup() {\n      clearTimeout(t);\n    };\n  }, []); ///todo: fix this\n\n  const numberOfSubs = window.currentSubs && window.currentSubs.filter(function (str) {\n    return str.indexOf('_AUDIO') === -1;\n  }).filter(function (str) {\n    return str.indexOf('_AUDIO') === -1;\n  }).filter(function (str) {\n    return str.indexOf(window.myName) === -1;\n  }).length; //number of subs, not counting audio-only or my name\n\n  useEffect(() => {\n    window.numberOfSubs = numberOfSubs;\n  }, [numberOfSubs]);\n\n  function getTiles() {\n    let largeTiles = [];\n    let smallTiles = [];\n    Object.entries(callState.callItems).forEach(([id, callItem]) => {\n      const isAudioOnly = () => {\n        if (!callItem.audioTrackState || !callItem.videoTrackState) {\n          return;\n        }\n\n        return callItem.audioTrackState.subscribed && !callItem.videoTrackState.subscribed;\n      };\n\n      const isLarge = isScreenShare(id) || !isLocal(id) && !containsScreenShare(callState.callItems) || isLocal(id) && numberOfSubs && numberOfSubs > 1 && !containsScreenShare(callState.callItems); //videoTrackState()\n\n      const tile = /*#__PURE__*/React.createElement(Tile, {\n        key: id,\n        videoTrackState: callItem.videoTrackState,\n        audioTrackState: callItem.audioTrackState,\n        isLocalPerson: isLocal(id),\n        isAudioOnly: isAudioOnly(),\n        isLarge: isLarge,\n        disableCornerMessage: isScreenShare(id),\n        isScreenShare: isScreenShare(id) // onClick={\n        //   isLocal(id)\n        //     ? null\n        //     : () => {\n        //         sendHello(id);\n        //       }\n        // }\n        ,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 292,\n          columnNumber: 9\n        }\n      });\n\n      if (isLarge) {\n        largeTiles.push(tile);\n      } else {\n        smallTiles.push(tile);\n      }\n    });\n    return [largeTiles, smallTiles];\n  }\n\n  const [largeTiles, smallTiles] = getTiles();\n  /**\n   * DELETE: Attached tiles objects to window for debugging purposes.\n   */\n\n  useEffect(() => {\n    // console.log('re-rendered');\n    // console.log('Userlist: ' + window.userList);\n    window.largeTiles = largeTiles;\n    window.smallTales = smallTiles;\n\n    window.add = function (n = 1) {\n      for (let i = 0; i < n; i++) {\n        callObject.addFakeParticipant();\n      }\n    };\n  }); // attach callState to window for debugging\n\n  useEffect(() => {\n    window.callState = callState;\n  }, [callState]);\n  const message = getMessage(callState);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: myState.amAdmin ? \"call-with-sidebar\" : \"call\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 348,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: `large-tiles count-${containsScreenShare(callState.callItems) && '1' || numberOfSubs && numberOfSubs + 1}`,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 350,\n      columnNumber: 7\n    }\n  }, !message ? largeTiles : null\n  /* Avoid showing large tiles to make room for the message */\n  ), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"small-tiles\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 357,\n      columnNumber: 7\n    }\n  }, smallTiles), message && /*#__PURE__*/React.createElement(CallMessage, {\n    header: message.header,\n    detail: message.detail,\n    isError: message.isError,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 359,\n      columnNumber: 9\n    }\n  }));\n}","map":{"version":3,"sources":["/Users/arlosb/Documents/GitHub/new react app/test4/src/components/Call/Call.js"],"names":["React","useEffect","useContext","useReducer","useCallback","useState","Tile","CallObjectContext","MyContext","SessionStateContext","CallMessage","initialCallState","CLICK_ALLOW_TIMEOUT","PARTICIPANTS_CHANGE","CAM_OR_MIC_ERROR","FATAL_ERROR","callReducer","isLocal","isScreenShare","containsScreenShare","getMessage","logDailyEvent","useSetSubscriptions","useForceUpdate","value","setValue","Call","callObject","session","sessionState","setSessionState","callState","dispatch","forceUpdate","myStateArray","setName","setRole","setUserList","setViewMode","setCamOn","setMicOnAtSessionStart","setAdminPresent","setAmAdmin","setNumber","myState","setMyState","window","updateCall","isActive","roleOf","Shadow1","Shadow2","Shadow3","Shadow4","role","myNewRole","key","name","includes","updateUserList","userListIncludesAdmin","ps","participants","workingUserList","names","sessionIdFor","p","thisUserName","user_name","thisSessionId","session_id","push","console","log","sort","events","handleNewParticipantsState","e","type","action","participant","event","getUserName","setInterval","clearInterval","on","cleanup","off","userList","handleCameraErrorEvent","message","errorMsg","handleErrorEvent","t","setTimeout","clearTimeout","numberOfSubs","currentSubs","filter","str","indexOf","myName","length","getTiles","largeTiles","smallTiles","Object","entries","callItems","forEach","id","callItem","isAudioOnly","audioTrackState","videoTrackState","subscribed","isLarge","tile","smallTales","add","n","i","addFakeParticipant","amAdmin","header","detail","isError"],"mappings":"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","sourcesContent":["import React, { useEffect, useContext, useReducer, useCallback, useState } from 'react';\nimport './Call.css';\nimport Tile from '../Tile/Tile';\nimport CallObjectContext from '../../CallObjectContext';\nimport MyContext from '../../MyContext';\nimport SessionStateContext from '../../SessionStateContext';\nimport CallMessage from '../CallMessage/CallMessage';\nimport {\n  initialCallState,\n  CLICK_ALLOW_TIMEOUT,\n  PARTICIPANTS_CHANGE,\n  CAM_OR_MIC_ERROR,\n  FATAL_ERROR,\n  callReducer,\n  isLocal,\n  isScreenShare,\n  containsScreenShare,\n  getMessage,\n} from './callState';\nimport { logDailyEvent } from '../../logUtils';\nimport useSetSubscriptions from '../../hooks/setSubscriptions';\nfunction useForceUpdate(){\n  const [value, setValue] = useState(0); // integer state\n  return () => setValue(value => value + 1); // update the state to force render\n}\n\nexport default function Call() {\n  useSetSubscriptions();\n  const callObject = useContext(CallObjectContext);\n  const { session } = useContext(SessionStateContext);\n  const [ sessionState,setSessionState] = session;\n  const [callState, dispatch] = useReducer(callReducer, initialCallState);\n  const forceUpdate = useForceUpdate();\n  const { myStateArray, \n          setName, \n          setRole,\n          setUserList,\n          setViewMode,\n          setCamOn,\n          setMicOnAtSessionStart,\n          setAdminPresent,\n          setAmAdmin, \n          setNumber,\n        } = useContext(MyContext);\n  const [ myState,setMyState ] = myStateArray;\n\n\n\n  window.updateCall = () => {\n    forceUpdate();\n  }\n\n\n\n /**\n   * Set default viewmode when session begins or my role changes\n   */\n  useEffect(()=> {\n    if(sessionState.isActive) {\n      if (sessionState.roleOf.Shadow1)\n        {setViewMode('Shadow1');}\n      else if (sessionState.roleOf.Shadow2)    //fallbacks in case shadow1 is not assigned\n        {setViewMode('Shadow2');}\n      else if (sessionState.roleOf.Shadow3)\n        {setViewMode('Shadow3');}\n      else if (sessionState.roleOf.Shadow4)\n        {setViewMode('Shadow4');}\n      else\n        {setViewMode('Seller');}\n    } else {setViewMode(null);}\n  },[sessionState.isActive,myState.role]);\n\n\n   /**\n   * Update my role according to sessionState changes\n   */\n   useEffect(()=> {\n    let myNewRole = 'Attendee'; //default, if no role assigned\n    for (const key in sessionState.roleOf) {\n        if(sessionState.roleOf[key]==myState.name) {\n            myNewRole = key;\n        }\n    }\n    if (myNewRole!==myState.role) {\n        setRole(myNewRole);\n          if (myNewRole.includes('1')) {\n              setNumber(1);\n          } else if (myNewRole.includes('2')) {\n              setNumber(2);\n          }\n      }\n   },[sessionState.roleOf])\n      \n\n   function updateUserList() {\n    let userListIncludesAdmin=false;\n    setAdminPresent(false);\n    let ps=callObject.participants(); \n    let workingUserList = {\n      names: [],\n      sessionIdFor: {},\n    }\n    for (const p in ps) {\n      let thisUserName = ps[p].user_name;\n      let thisSessionId = ps[p].session_id;\n      workingUserList.names.push(thisUserName);      //add each user_name with its sessionID to UserList\n      workingUserList.sessionIdFor[thisUserName] = thisSessionId;\n      if (thisUserName.includes('_Admin') && p!=='local') {\n          userListIncludesAdmin = true;\n      } \n    };\n    userListIncludesAdmin ? console.log('Admin IS present') : console.log('Admin IS NOT present');\n    setAdminPresent(userListIncludesAdmin);\n    workingUserList.names.sort();       //alphebetize that list \n    console.log(`now the userList is: ${workingUserList.names}`);  //print userList\n\n    setUserList(workingUserList);\n  }\n\n\n  /**\n   * Start listening for participant changes, when the callObject is set.\n   */\n  useEffect(() => {\n    if (!callObject) return;\n\n    const events = [\n      'participant-joined',\n      'participant-updated',\n      'participant-left',\n      'joined-meeting'\n    ];\n\n   \n\n    function handleNewParticipantsState(e) {\n      e && logDailyEvent(e);\n      dispatch({\n        type: PARTICIPANTS_CHANGE,\n        participants: callObject.participants(),\n      });\n\n      if(e && e.action!='participant-updated') {\n          \n          let thisUserName = e.participant.user_name;\n\n          if (e.action==\"participant-joined\" || e.action==\"participant-left\") {\n            window.event=e;\n            const getUserName = setInterval(   //necessary only because emitted event doesn't include participant's name at first :/\n              ()=>{\n                    if (thisUserName) \n                      {updateUserList();\n                      clearInterval(getUserName);\n                      }\n                  },100);\n          }          \n      } \n    }\n\n    // Use initial state\n    handleNewParticipantsState();\n\n    // Listen for changes in state\n    for (const event of events) {\n      callObject.on(event, handleNewParticipantsState);\n    }\n\n    // Stop listening for changes in state\n    return function cleanup() {\n      for (const event of events) {\n        callObject.off(event, handleNewParticipantsState);\n      }\n    };\n  }, [callObject]);\n\n  /**\n   * Attach userList to window for debugging\n   */\n  useEffect (()=> {\n    window.userList=myState.userList;\n  },[myState.userList])\n\n /**\n   * Attach sessionState to window for debugging\n   */\n  useEffect(()=> {\n    window.sessionState=sessionState;\n},[sessionState]);\n\n /**\n   * Attach myState to window for debugging\n   */\n  useEffect(()=> {\n    window.myState=myState;\n},[myState]);\n\n  /**\n   * Start listening for call errors, when the callObject is set.\n   */\n  useEffect(() => {\n    if (!callObject) return;\n\n    function handleCameraErrorEvent(event) {\n      logDailyEvent(event);\n      dispatch({\n        type: CAM_OR_MIC_ERROR,\n        message:\n          (event && event.errorMsg && event.errorMsg.errorMsg) || 'Unknown',\n      });\n    }\n\n    // We're making an assumption here: there is no camera error when callObject\n    // is first assigned.\n\n    callObject.on('camera-error', handleCameraErrorEvent);\n\n    return function cleanup() {\n      callObject.off('camera-error', handleCameraErrorEvent);\n    };\n  }, [callObject]);\n\n\n  \n\n  /**\n   * Start listening for fatal errors, when the callObject is set.\n   */\n  useEffect(() => {\n    if (!callObject) return;\n\n    function handleErrorEvent(e) {\n      logDailyEvent(e);\n      dispatch({\n        type: FATAL_ERROR,\n        message: (e && e.errorMsg) || 'Unknown',\n      });\n    }\n\n    // We're making an assumption here: there is no error when callObject is\n    // first assigned.\n\n    callObject.on('error', handleErrorEvent);\n\n    return function cleanup() {\n      callObject.off('error', handleErrorEvent);\n    };\n  }, [callObject]);\n\n  /**\n   * Start a timer to show the \"click allow\" message, when the component mounts.\n   */\n  useEffect(() => {\n    const t = setTimeout(() => {\n      dispatch({ type: CLICK_ALLOW_TIMEOUT });\n    }, 2500);\n\n    return function cleanup() {\n      clearTimeout(t);\n    };\n  }, []);\n\n  ///todo: fix this\n  const numberOfSubs = window.currentSubs && window.currentSubs.filter(function (str) {return str.indexOf('_AUDIO') === -1}).filter(function (str) {return str.indexOf('_AUDIO') === -1}).filter(function (str) {return str.indexOf(window.myName) === -1}).length //number of subs, not counting audio-only or my name\n\n\n  useEffect(()=>{\nwindow.numberOfSubs =numberOfSubs;\n  },[numberOfSubs])\n\n\n\n \n\n  function getTiles() {\n    let largeTiles = [];\n    let smallTiles = [];\n    Object.entries(callState.callItems).forEach(([id, callItem]) => {\n\n\n      const isAudioOnly = () => {\n        if(!callItem.audioTrackState || !callItem.videoTrackState) {return}\n        return (callItem.audioTrackState.subscribed && !callItem.videoTrackState.subscribed);\n      }\n\n      const isLarge =\n        isScreenShare(id) ||\n        (!isLocal(id) && !containsScreenShare(callState.callItems)) \n        || (isLocal(id) && numberOfSubs && numberOfSubs>1 && !containsScreenShare(callState.callItems))   //videoTrackState()\n\n        \n      const tile = (\n        <Tile\n          key={id}\n          videoTrackState={callItem.videoTrackState}\n          audioTrackState={callItem.audioTrackState}\n          isLocalPerson={isLocal(id)}\n          isAudioOnly={isAudioOnly()}\n          isLarge={isLarge}\n          disableCornerMessage={isScreenShare(id)}\n          isScreenShare={isScreenShare(id)}\n          // onClick={\n          //   isLocal(id)\n          //     ? null\n          //     : () => {\n          //         sendHello(id);\n          //       }\n          // }\n        />\n      );\n      if (isLarge) {\n        largeTiles.push(tile);\n      } else {\n        smallTiles.push(tile);\n      }\n    });\n    \n    return [largeTiles, smallTiles];\n  }\n\n  const [largeTiles, smallTiles] = getTiles();\n\n  \n  /**\n   * DELETE: Attached tiles objects to window for debugging purposes.\n   */\n  useEffect(() => {\n    // console.log('re-rendered');\n    // console.log('Userlist: ' + window.userList);\n    window.largeTiles = largeTiles;\n    window.smallTales = smallTiles;\n    window.add = function(n=1) {\n      for(let i=0;i<n;i++) {\n        callObject.addFakeParticipant()\n      }\n    };\n    \n  }); \n\n\n   // attach callState to window for debugging\n   useEffect(() => {\n    window.callState = callState;\n  }, [callState]); \n\n\n  const message = getMessage(callState);\n  return (\n    <div className={myState.amAdmin ? \"call-with-sidebar\" : \"call\"}>\n                                      {/* add # of tiles to class name. alternative: {largeTiles.length}*/}\n      <div className={`large-tiles count-${(containsScreenShare(callState.callItems)&&'1')||numberOfSubs && numberOfSubs+1}`}>   \n        {\n          !message\n            ? largeTiles\n            : null /* Avoid showing large tiles to make room for the message */\n        }\n      </div>\n      <div className=\"small-tiles\">{smallTiles}</div>\n      {message && (\n        <CallMessage\n          header={message.header}\n          detail={message.detail}\n          isError={message.isError}\n        />\n      )}\n    </div>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}