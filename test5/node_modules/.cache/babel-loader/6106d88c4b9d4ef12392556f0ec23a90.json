{"ast":null,"code":"var _objectSpread = require(\"/Users/arlosb/Documents/GitHub/new react app/test5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/arlosb/Documents/GitHub/new react app/test5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/arlosb/Documents/GitHub/new react app/test5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _slicedToArray = require(\"/Users/arlosb/Documents/GitHub/new react app/test5/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\n/*!\n * JWT - Signed URL Helpers\n * Note: Hacking this module into a class with static methods because ESDoc forces it. We'll revisit ESDoc later.\n * Documentationjs looks real nice.\n */\nvar fs = require('fs');\n\nvar jwt = require('jsonwebtoken');\n\nvar typeToClaim = function typeToClaim(type) {\n  var typeMap = {\n    video: 'v',\n    thumbnail: 't',\n    gif: 'g',\n    storyboard: 's'\n  };\n  return typeMap[type];\n};\n\nvar getSigningKey = function getSigningKey(options) {\n  var keyId = options.keyId || process.env.MUX_SIGNING_KEY;\n\n  if (!keyId) {\n    throw new TypeError('Signing Key ID required');\n  }\n\n  return keyId;\n};\n\nvar getPrivateKey = function getPrivateKey(options) {\n  var key;\n\n  if (options.keySecret) {\n    key = options.keySecret;\n  } else if (options.keyFilePath) {\n    key = fs.readFileSync(options.keyFilePath);\n  } else if (process.env.MUX_PRIVATE_KEY) {\n    key = Buffer.from(process.env.MUX_PRIVATE_KEY, 'base64');\n  }\n\n  if (key) {\n    var _key$toString$split = key.toString().split('\\n'),\n        _key$toString$split2 = _slicedToArray(_key$toString$split, 1),\n        rsaHeader = _key$toString$split2[0];\n\n    if (rsaHeader === '-----BEGIN RSA PRIVATE KEY-----') {\n      return key;\n    }\n\n    try {\n      return Buffer.from(key, 'base64');\n    } catch (err) {\n      throw new TypeError('Specified signing key must be either a valid PEM string or a base64 encoded PEM.');\n    }\n  }\n\n  throw new TypeError('Signing Key ID required');\n};\n/**\n * JWT - Signed URL token generation helpers\n *\n * @example\n * const Mux = require('@mux/mux-node');\n *\n * const token = Mux.JWT.sign('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' })\n */\n\n\nvar JWT = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function JWT() {\n    _classCallCheck(this, JWT);\n  }\n\n  _createClass(JWT, null, [{\n    key: \"sign\",\n\n    /**\n     * Creates a new token to be used with a signed playback ID\n     * @param {string} playbackId - The Playback ID (of type 'signed') that you'd like to generate a token for.\n     * @param {Object} options - Configuration options to use when creating the token\n     * @param {string} [options.keyId] - The signing key ID to use. If not specified, process.env.MUX_SIGNING_KEY is attempted\n     * @param {string} [options.keySecret] - The signing key secret. If not specified, process.env.MUX_PRIVATE_KEY is used.\n     * @param {string} [options.type=video] - Type of token this will be. Valid types are `video`, `thumbnail`, `gif`, or `storyboard`\n     * @param {string} [options.expiration=7d] - Length of time for the token to be valid.\n     * @param {Object} [options.params] - Any additional query params you'd use with a public url. For example, with a thumbnail this would be values such as `time`.\n     * @returns {string} - Returns a token to be used with a signed URL.\n     *\n     * @example\n     * const Mux = require('@mux/mux-node');\n     *\n     * const token = Mux.JWT.sign('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' });\n     * // Now you can use the token in a url: `https://stream.mux.com/some-playback-id.m3u8?token=${token}`\n     */\n    value: function sign(playbackId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var opts = _objectSpread({\n        type: 'video',\n        expiration: '7d',\n        params: {}\n      }, options);\n\n      var keyId = getSigningKey(options);\n      var keySecret = getPrivateKey(options);\n      var tokenOptions = {\n        keyid: keyId,\n        subject: playbackId,\n        audience: typeToClaim(opts.type),\n        expiresIn: opts.expiration,\n        noTimestamp: true,\n        algorithm: 'RS256'\n      };\n      return jwt.sign(opts.params, keySecret, tokenOptions);\n    }\n    /**\n     * Decodes an existing token.\n     *\n     * Note: This does not cryptographically verify the token signature, it simply decodes the values.\n     * @param {string} token - The token you'd like to decode.\n     * @returns {Object} - If the token could be decoded, it returns the decoded token object\n     *\n     * @example\n     * const Mux = require('@mux/mux-node');\n     *\n     * const token = Mux.JWT.sign('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' });\n     * const decoded = Mux.JWT.decode(token);\n     * // decoded will be the raw decoded JWT, so you'll see keys like `aud`, `exp`, etc.\n     */\n\n  }, {\n    key: \"decode\",\n    value: function decode(token) {\n      return jwt.decode(token);\n    }\n  }]);\n\n  return JWT;\n}();\n\nmodule.exports = JWT;","map":null,"metadata":{},"sourceType":"script"}