{"ast":null,"code":"/*!\n * JWT - Signed URL Helpers\n * Note: Hacking this module into a class with static methods because ESDoc forces it. We'll revisit ESDoc later.\n * Documentationjs looks real nice.\n */\nconst fs = require('fs');\n\nconst jwt = require('jsonwebtoken');\n\nconst typeToClaim = type => {\n  const typeMap = {\n    video: 'v',\n    thumbnail: 't',\n    gif: 'g',\n    storyboard: 's'\n  };\n  return typeMap[type];\n};\n\nconst getSigningKey = options => {\n  const keyId = options.keyId || process.env.MUX_SIGNING_KEY;\n\n  if (!keyId) {\n    throw new TypeError('Signing Key ID required');\n  }\n\n  return keyId;\n};\n\nconst getPrivateKey = options => {\n  let key;\n\n  if (options.keySecret) {\n    key = options.keySecret;\n  } else if (options.keyFilePath) {\n    key = fs.readFileSync(options.keyFilePath);\n  } else if (process.env.MUX_PRIVATE_KEY) {\n    key = Buffer.from(process.env.MUX_PRIVATE_KEY, 'base64');\n  }\n\n  if (key) {\n    const [rsaHeader] = key.toString().split('\\n');\n\n    if (rsaHeader === '-----BEGIN RSA PRIVATE KEY-----') {\n      return key;\n    }\n\n    try {\n      return Buffer.from(key, 'base64');\n    } catch (err) {\n      throw new TypeError('Specified signing key must be either a valid PEM string or a base64 encoded PEM.');\n    }\n  }\n\n  throw new TypeError('Signing Key ID required');\n};\n/**\n * JWT - Signed URL token generation helpers\n *\n * @example\n * const Mux = require('@mux/mux-node');\n *\n * const token = Mux.JWT.sign('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' })\n */\n\n\nclass JWT {\n  /**\n   * Creates a new token to be used with a signed playback ID\n   * @param {string} playbackId - The Playback ID (of type 'signed') that you'd like to generate a token for.\n   * @param {Object} options - Configuration options to use when creating the token\n   * @param {string} [options.keyId] - The signing key ID to use. If not specified, process.env.MUX_SIGNING_KEY is attempted\n   * @param {string} [options.keySecret] - The signing key secret. If not specified, process.env.MUX_PRIVATE_KEY is used.\n   * @param {string} [options.type=video] - Type of token this will be. Valid types are `video`, `thumbnail`, `gif`, or `storyboard`\n   * @param {string} [options.expiration=7d] - Length of time for the token to be valid.\n   * @param {Object} [options.params] - Any additional query params you'd use with a public url. For example, with a thumbnail this would be values such as `time`.\n   * @returns {string} - Returns a token to be used with a signed URL.\n   *\n   * @example\n   * const Mux = require('@mux/mux-node');\n   *\n   * const token = Mux.JWT.sign('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' });\n   * // Now you can use the token in a url: `https://stream.mux.com/some-playback-id.m3u8?token=${token}`\n   */\n  static sign(playbackId, options = {}) {\n    const opts = {\n      type: 'video',\n      expiration: '7d',\n      params: {},\n      ...options\n    };\n    const keyId = getSigningKey(options);\n    const keySecret = getPrivateKey(options);\n    const tokenOptions = {\n      keyid: keyId,\n      subject: playbackId,\n      audience: typeToClaim(opts.type),\n      expiresIn: opts.expiration,\n      noTimestamp: true,\n      algorithm: 'RS256'\n    };\n    return jwt.sign(opts.params, keySecret, tokenOptions);\n  }\n  /**\n   * Decodes an existing token.\n   *\n   * Note: This does not cryptographically verify the token signature, it simply decodes the values.\n   * @param {string} token - The token you'd like to decode.\n   * @returns {Object} - If the token could be decoded, it returns the decoded token object\n   *\n   * @example\n   * const Mux = require('@mux/mux-node');\n   *\n   * const token = Mux.JWT.sign('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' });\n   * const decoded = Mux.JWT.decode(token);\n   * // decoded will be the raw decoded JWT, so you'll see keys like `aud`, `exp`, etc.\n   */\n\n\n  static decode(token) {\n    return jwt.decode(token);\n  }\n\n}\n\nmodule.exports = JWT;","map":{"version":3,"sources":["/Users/arlosb/Documents/GitHub/node_modules/@mux/mux-node/src/utils/jwt.js"],"names":["fs","require","jwt","typeToClaim","type","typeMap","video","thumbnail","gif","storyboard","getSigningKey","options","keyId","process","env","MUX_SIGNING_KEY","TypeError","getPrivateKey","key","keySecret","keyFilePath","readFileSync","MUX_PRIVATE_KEY","Buffer","from","rsaHeader","toString","split","err","JWT","sign","playbackId","opts","expiration","params","tokenOptions","keyid","subject","audience","expiresIn","noTimestamp","algorithm","decode","token","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,cAAD,CAAnB;;AAEA,MAAME,WAAW,GAAGC,IAAI,IAAI;AAC1B,QAAMC,OAAO,GAAG;AACdC,IAAAA,KAAK,EAAE,GADO;AAEdC,IAAAA,SAAS,EAAE,GAFG;AAGdC,IAAAA,GAAG,EAAE,GAHS;AAIdC,IAAAA,UAAU,EAAE;AAJE,GAAhB;AAOA,SAAOJ,OAAO,CAACD,IAAD,CAAd;AACD,CATD;;AAWA,MAAMM,aAAa,GAAGC,OAAO,IAAI;AAC/B,QAAMC,KAAK,GAAGD,OAAO,CAACC,KAAR,IAAiBC,OAAO,CAACC,GAAR,CAAYC,eAA3C;;AACA,MAAI,CAACH,KAAL,EAAY;AACV,UAAM,IAAII,SAAJ,CAAc,yBAAd,CAAN;AACD;;AAED,SAAOJ,KAAP;AACD,CAPD;;AASA,MAAMK,aAAa,GAAGN,OAAO,IAAI;AAC/B,MAAIO,GAAJ;;AACA,MAAIP,OAAO,CAACQ,SAAZ,EAAuB;AACrBD,IAAAA,GAAG,GAAGP,OAAO,CAACQ,SAAd;AACD,GAFD,MAEO,IAAIR,OAAO,CAACS,WAAZ,EAAyB;AAC9BF,IAAAA,GAAG,GAAGlB,EAAE,CAACqB,YAAH,CAAgBV,OAAO,CAACS,WAAxB,CAAN;AACD,GAFM,MAEA,IAAIP,OAAO,CAACC,GAAR,CAAYQ,eAAhB,EAAiC;AACtCJ,IAAAA,GAAG,GAAGK,MAAM,CAACC,IAAP,CAAYX,OAAO,CAACC,GAAR,CAAYQ,eAAxB,EAAyC,QAAzC,CAAN;AACD;;AAED,MAAIJ,GAAJ,EAAS;AACP,UAAM,CAACO,SAAD,IAAcP,GAAG,CAACQ,QAAJ,GAAeC,KAAf,CAAqB,IAArB,CAApB;;AACA,QAAIF,SAAS,KAAK,iCAAlB,EAAqD;AACnD,aAAOP,GAAP;AACD;;AAED,QAAI;AACF,aAAOK,MAAM,CAACC,IAAP,CAAYN,GAAZ,EAAiB,QAAjB,CAAP;AACD,KAFD,CAEE,OAAOU,GAAP,EAAY;AACZ,YAAM,IAAIZ,SAAJ,CACJ,kFADI,CAAN;AAGD;AACF;;AAED,QAAM,IAAIA,SAAJ,CAAc,yBAAd,CAAN;AACD,CA1BD;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMa,GAAN,CAAU;AACR;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,SAAOC,IAAP,CAAYC,UAAZ,EAAwBpB,OAAO,GAAG,EAAlC,EAAsC;AACpC,UAAMqB,IAAI,GAAG;AACX5B,MAAAA,IAAI,EAAE,OADK;AAEX6B,MAAAA,UAAU,EAAE,IAFD;AAGXC,MAAAA,MAAM,EAAE,EAHG;AAIX,SAAGvB;AAJQ,KAAb;AAOA,UAAMC,KAAK,GAAGF,aAAa,CAACC,OAAD,CAA3B;AACA,UAAMQ,SAAS,GAAGF,aAAa,CAACN,OAAD,CAA/B;AAEA,UAAMwB,YAAY,GAAG;AACnBC,MAAAA,KAAK,EAAExB,KADY;AAEnByB,MAAAA,OAAO,EAAEN,UAFU;AAGnBO,MAAAA,QAAQ,EAAEnC,WAAW,CAAC6B,IAAI,CAAC5B,IAAN,CAHF;AAInBmC,MAAAA,SAAS,EAAEP,IAAI,CAACC,UAJG;AAKnBO,MAAAA,WAAW,EAAE,IALM;AAMnBC,MAAAA,SAAS,EAAE;AANQ,KAArB;AASA,WAAOvC,GAAG,CAAC4B,IAAJ,CAASE,IAAI,CAACE,MAAd,EAAsBf,SAAtB,EAAiCgB,YAAjC,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,SAAOO,MAAP,CAAcC,KAAd,EAAqB;AACnB,WAAOzC,GAAG,CAACwC,MAAJ,CAAWC,KAAX,CAAP;AACD;;AAzDO;;AA4DVC,MAAM,CAACC,OAAP,GAAiBhB,GAAjB","sourcesContent":["/*!\n * JWT - Signed URL Helpers\n * Note: Hacking this module into a class with static methods because ESDoc forces it. We'll revisit ESDoc later.\n * Documentationjs looks real nice.\n */\nconst fs = require('fs');\nconst jwt = require('jsonwebtoken');\n\nconst typeToClaim = type => {\n  const typeMap = {\n    video: 'v',\n    thumbnail: 't',\n    gif: 'g',\n    storyboard: 's',\n  };\n\n  return typeMap[type];\n};\n\nconst getSigningKey = options => {\n  const keyId = options.keyId || process.env.MUX_SIGNING_KEY;\n  if (!keyId) {\n    throw new TypeError('Signing Key ID required');\n  }\n\n  return keyId;\n};\n\nconst getPrivateKey = options => {\n  let key;\n  if (options.keySecret) {\n    key = options.keySecret;\n  } else if (options.keyFilePath) {\n    key = fs.readFileSync(options.keyFilePath);\n  } else if (process.env.MUX_PRIVATE_KEY) {\n    key = Buffer.from(process.env.MUX_PRIVATE_KEY, 'base64');\n  }\n\n  if (key) {\n    const [rsaHeader] = key.toString().split('\\n');\n    if (rsaHeader === '-----BEGIN RSA PRIVATE KEY-----') {\n      return key;\n    }\n\n    try {\n      return Buffer.from(key, 'base64');\n    } catch (err) {\n      throw new TypeError(\n        'Specified signing key must be either a valid PEM string or a base64 encoded PEM.'\n      );\n    }\n  }\n\n  throw new TypeError('Signing Key ID required');\n};\n\n/**\n * JWT - Signed URL token generation helpers\n *\n * @example\n * const Mux = require('@mux/mux-node');\n *\n * const token = Mux.JWT.sign('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' })\n */\nclass JWT {\n  /**\n   * Creates a new token to be used with a signed playback ID\n   * @param {string} playbackId - The Playback ID (of type 'signed') that you'd like to generate a token for.\n   * @param {Object} options - Configuration options to use when creating the token\n   * @param {string} [options.keyId] - The signing key ID to use. If not specified, process.env.MUX_SIGNING_KEY is attempted\n   * @param {string} [options.keySecret] - The signing key secret. If not specified, process.env.MUX_PRIVATE_KEY is used.\n   * @param {string} [options.type=video] - Type of token this will be. Valid types are `video`, `thumbnail`, `gif`, or `storyboard`\n   * @param {string} [options.expiration=7d] - Length of time for the token to be valid.\n   * @param {Object} [options.params] - Any additional query params you'd use with a public url. For example, with a thumbnail this would be values such as `time`.\n   * @returns {string} - Returns a token to be used with a signed URL.\n   *\n   * @example\n   * const Mux = require('@mux/mux-node');\n   *\n   * const token = Mux.JWT.sign('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' });\n   * // Now you can use the token in a url: `https://stream.mux.com/some-playback-id.m3u8?token=${token}`\n   */\n  static sign(playbackId, options = {}) {\n    const opts = {\n      type: 'video',\n      expiration: '7d',\n      params: {},\n      ...options,\n    };\n\n    const keyId = getSigningKey(options);\n    const keySecret = getPrivateKey(options);\n\n    const tokenOptions = {\n      keyid: keyId,\n      subject: playbackId,\n      audience: typeToClaim(opts.type),\n      expiresIn: opts.expiration,\n      noTimestamp: true,\n      algorithm: 'RS256',\n    };\n\n    return jwt.sign(opts.params, keySecret, tokenOptions);\n  }\n\n  /**\n   * Decodes an existing token.\n   *\n   * Note: This does not cryptographically verify the token signature, it simply decodes the values.\n   * @param {string} token - The token you'd like to decode.\n   * @returns {Object} - If the token could be decoded, it returns the decoded token object\n   *\n   * @example\n   * const Mux = require('@mux/mux-node');\n   *\n   * const token = Mux.JWT.sign('some-playback-id', { keyId: 'your key id', keySecret: 'your key secret' });\n   * const decoded = Mux.JWT.decode(token);\n   * // decoded will be the raw decoded JWT, so you'll see keys like `aud`, `exp`, etc.\n   */\n  static decode(token) {\n    return jwt.decode(token);\n  }\n}\n\nmodule.exports = JWT;\n"]},"metadata":{},"sourceType":"script"}