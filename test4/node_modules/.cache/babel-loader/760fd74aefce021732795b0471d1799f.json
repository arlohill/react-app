{"ast":null,"code":"var _jsxFileName = \"/Users/arlosb/Documents/GitHub/new react app/my-app/src/components/Call/Call.js\";\nimport React, { useEffect, useContext, useReducer, useCallback } from 'react';\nimport './Call.css';\nimport Tile from '../Tile/Tile';\nimport CallObjectContext from '../../CallObjectContext';\nimport CallMessage from '../CallMessage/CallMessage';\nimport { initialCallState, CLICK_ALLOW_TIMEOUT, PARTICIPANTS_CHANGE, CAM_OR_MIC_ERROR, FATAL_ERROR, callReducer, isLocal, isScreenShare, containsScreenShare, getMessage } from './callState';\nimport { logDailyEvent } from '../../logUtils';\nexport default function Call() {\n  const callObject = useContext(CallObjectContext);\n  const [callState, dispatch] = useReducer(callReducer, initialCallState);\n  /**\n   * Start listening for participant changes, when the callObject is set.\n   */\n\n  useEffect(() => {\n    if (!callObject) return;\n    const events = ['participant-joined', 'participant-updated', 'participant-left'];\n\n    function handleNewParticipantsState(event) {\n      event && logDailyEvent(event);\n      dispatch({\n        type: PARTICIPANTS_CHANGE,\n        participants: callObject.participants()\n      });\n    } // Use initial state\n\n\n    handleNewParticipantsState(); // Listen for changes in state\n\n    for (const event of events) {\n      callObject.on(event, handleNewParticipantsState);\n    } // Stop listening for changes in state\n\n\n    return function cleanup() {\n      for (const event of events) {\n        callObject.off(event, handleNewParticipantsState);\n      }\n    };\n  }, [callObject]);\n  /**\n   * Start listening for call errors, when the callObject is set.\n   */\n\n  useEffect(() => {\n    if (!callObject) return;\n\n    function handleCameraErrorEvent(event) {\n      logDailyEvent(event);\n      dispatch({\n        type: CAM_OR_MIC_ERROR,\n        message: event && event.errorMsg && event.errorMsg.errorMsg || 'Unknown'\n      });\n    } // We're making an assumption here: there is no camera error when callObject\n    // is first assigned.\n\n\n    callObject.on('camera-error', handleCameraErrorEvent);\n    return function cleanup() {\n      callObject.off('camera-error', handleCameraErrorEvent);\n    };\n  }, [callObject]);\n  /**\n   * Start listening for fatal errors, when the callObject is set.\n   */\n\n  useEffect(() => {\n    if (!callObject) return;\n\n    function handleErrorEvent(e) {\n      logDailyEvent(e);\n      dispatch({\n        type: FATAL_ERROR,\n        message: e && e.errorMsg || 'Unknown'\n      });\n    } // We're making an assumption here: there is no error when callObject is\n    // first assigned.\n\n\n    callObject.on('error', handleErrorEvent);\n    return function cleanup() {\n      callObject.off('error', handleErrorEvent);\n    };\n  }, [callObject]);\n  /**\n   * Start a timer to show the \"click allow\" message, when the component mounts.\n   */\n\n  useEffect(() => {\n    const t = setTimeout(() => {\n      dispatch({\n        type: CLICK_ALLOW_TIMEOUT\n      });\n    }, 2500);\n    return function cleanup() {\n      clearTimeout(t);\n    };\n  }, []);\n  /**\n   * Send an app message to the remote participant whose tile was clicked on.\n   */\n\n  const sendHello = useCallback(participantId => {\n    callObject && callObject.sendAppMessage({\n      hello: 'world'\n    }, participantId);\n  }, [callObject]);\n\n  function getTiles() {\n    let largeTiles = [];\n    let smallTiles = [];\n    Object.entries(callState.callItems).forEach(([id, callItem]) => {\n      const isLarge = isScreenShare(id) || !isLocal(id) && !containsScreenShare(callState.callItems);\n      const tile = /*#__PURE__*/React.createElement(Tile, {\n        key: id,\n        videoTrackState: callItem.videoTrackState,\n        audioTrackState: callItem.audioTrackState,\n        isLocalPerson: isLocal(id),\n        isLarge: isLarge,\n        disableCornerMessage: isScreenShare(id),\n        onClick: isLocal(id) ? null : () => {\n          sendHello(id);\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 141,\n          columnNumber: 9\n        }\n      });\n\n      if (isLarge) {\n        largeTiles.push(tile);\n      } else {\n        smallTiles.push(tile);\n      }\n    });\n    return [largeTiles, smallTiles];\n  }\n\n  const [largeTiles, smallTiles] = getTiles();\n  /**\n   * DELETE: Attached tiles objects to window for debugging purposes.\n   */\n\n  useEffect(() => {\n    window.largeTiles = largeTiles;\n    window.smallTales = smallTiles;\n  });\n  const message = getMessage(callState);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"call\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 181,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: `large-tiles ${largeTiles.length()}`,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 182,\n      columnNumber: 7\n    }\n  }, !message ? largeTiles : null\n  /* Avoid showing large tiles to make room for the message */\n  ), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"small-tiles\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 189,\n      columnNumber: 7\n    }\n  }, smallTiles), message && /*#__PURE__*/React.createElement(CallMessage, {\n    header: message.header,\n    detail: message.detail,\n    isError: message.isError,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 191,\n      columnNumber: 9\n    }\n  }));\n}","map":{"version":3,"sources":["/Users/arlosb/Documents/GitHub/new react app/my-app/src/components/Call/Call.js"],"names":["React","useEffect","useContext","useReducer","useCallback","Tile","CallObjectContext","CallMessage","initialCallState","CLICK_ALLOW_TIMEOUT","PARTICIPANTS_CHANGE","CAM_OR_MIC_ERROR","FATAL_ERROR","callReducer","isLocal","isScreenShare","containsScreenShare","getMessage","logDailyEvent","Call","callObject","callState","dispatch","events","handleNewParticipantsState","event","type","participants","on","cleanup","off","handleCameraErrorEvent","message","errorMsg","handleErrorEvent","e","t","setTimeout","clearTimeout","sendHello","participantId","sendAppMessage","hello","getTiles","largeTiles","smallTiles","Object","entries","callItems","forEach","id","callItem","isLarge","tile","videoTrackState","audioTrackState","push","window","smallTales","length","header","detail","isError"],"mappings":"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","sourcesContent":["import React, { useEffect, useContext, useReducer, useCallback } from 'react';\nimport './Call.css';\nimport Tile from '../Tile/Tile';\nimport CallObjectContext from '../../CallObjectContext';\nimport CallMessage from '../CallMessage/CallMessage';\nimport {\n  initialCallState,\n  CLICK_ALLOW_TIMEOUT,\n  PARTICIPANTS_CHANGE,\n  CAM_OR_MIC_ERROR,\n  FATAL_ERROR,\n  callReducer,\n  isLocal,\n  isScreenShare,\n  containsScreenShare,\n  getMessage,\n} from './callState';\nimport { logDailyEvent } from '../../logUtils';\n\nexport default function Call() {\n  const callObject = useContext(CallObjectContext);\n  const [callState, dispatch] = useReducer(callReducer, initialCallState);\n\n  /**\n   * Start listening for participant changes, when the callObject is set.\n   */\n  useEffect(() => {\n    if (!callObject) return;\n\n    const events = [\n      'participant-joined',\n      'participant-updated',\n      'participant-left',\n    ];\n\n    function handleNewParticipantsState(event) {\n      event && logDailyEvent(event);\n      dispatch({\n        type: PARTICIPANTS_CHANGE,\n        participants: callObject.participants(),\n      });\n    }\n\n    // Use initial state\n    handleNewParticipantsState();\n\n    // Listen for changes in state\n    for (const event of events) {\n      callObject.on(event, handleNewParticipantsState);\n    }\n\n    // Stop listening for changes in state\n    return function cleanup() {\n      for (const event of events) {\n        callObject.off(event, handleNewParticipantsState);\n      }\n    };\n  }, [callObject]);\n\n  /**\n   * Start listening for call errors, when the callObject is set.\n   */\n  useEffect(() => {\n    if (!callObject) return;\n\n    function handleCameraErrorEvent(event) {\n      logDailyEvent(event);\n      dispatch({\n        type: CAM_OR_MIC_ERROR,\n        message:\n          (event && event.errorMsg && event.errorMsg.errorMsg) || 'Unknown',\n      });\n    }\n\n    // We're making an assumption here: there is no camera error when callObject\n    // is first assigned.\n\n    callObject.on('camera-error', handleCameraErrorEvent);\n\n    return function cleanup() {\n      callObject.off('camera-error', handleCameraErrorEvent);\n    };\n  }, [callObject]);\n\n  /**\n   * Start listening for fatal errors, when the callObject is set.\n   */\n  useEffect(() => {\n    if (!callObject) return;\n\n    function handleErrorEvent(e) {\n      logDailyEvent(e);\n      dispatch({\n        type: FATAL_ERROR,\n        message: (e && e.errorMsg) || 'Unknown',\n      });\n    }\n\n    // We're making an assumption here: there is no error when callObject is\n    // first assigned.\n\n    callObject.on('error', handleErrorEvent);\n\n    return function cleanup() {\n      callObject.off('error', handleErrorEvent);\n    };\n  }, [callObject]);\n\n  /**\n   * Start a timer to show the \"click allow\" message, when the component mounts.\n   */\n  useEffect(() => {\n    const t = setTimeout(() => {\n      dispatch({ type: CLICK_ALLOW_TIMEOUT });\n    }, 2500);\n\n    return function cleanup() {\n      clearTimeout(t);\n    };\n  }, []);\n\n  /**\n   * Send an app message to the remote participant whose tile was clicked on.\n   */\n  const sendHello = useCallback(\n    (participantId) => {\n      callObject &&\n        callObject.sendAppMessage({ hello: 'world' }, participantId);\n    },\n    [callObject]\n  );\n\n  function getTiles() {\n    let largeTiles = [];\n    let smallTiles = [];\n    Object.entries(callState.callItems).forEach(([id, callItem]) => {\n      const isLarge =\n        isScreenShare(id) ||\n        (!isLocal(id) && !containsScreenShare(callState.callItems));\n      const tile = (\n        <Tile\n          key={id}\n          videoTrackState={callItem.videoTrackState}\n          audioTrackState={callItem.audioTrackState}\n          isLocalPerson={isLocal(id)}\n          isLarge={isLarge}\n          disableCornerMessage={isScreenShare(id)}\n          onClick={\n            isLocal(id)\n              ? null\n              : () => {\n                  sendHello(id);\n                }\n          }\n        />\n      );\n      if (isLarge) {\n        largeTiles.push(tile);\n      } else {\n        smallTiles.push(tile);\n      }\n    });\n    \n    return [largeTiles, smallTiles];\n  }\n\n  const [largeTiles, smallTiles] = getTiles();\n\n  \n  /**\n   * DELETE: Attached tiles objects to window for debugging purposes.\n   */\n  useEffect(() => {\n    window.largeTiles = largeTiles;\n    window.smallTales = smallTiles;\n  }); \n\n\n  const message = getMessage(callState);\n  return (\n    <div className=\"call\">\n      <div className={`large-tiles ${largeTiles.length()}`}>\n        {\n          !message\n            ? largeTiles\n            : null /* Avoid showing large tiles to make room for the message */\n        }\n      </div>\n      <div className=\"small-tiles\">{smallTiles}</div>\n      {message && (\n        <CallMessage\n          header={message.header}\n          detail={message.detail}\n          isError={message.isError}\n        />\n      )}\n    </div>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}