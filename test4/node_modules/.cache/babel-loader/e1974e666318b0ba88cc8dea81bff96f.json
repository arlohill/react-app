{"ast":null,"code":"import { useState, useCallback, useEffect } from 'react';\nimport { sortByKey } from '../lib/sortByKey';\nexport const DEVICE_STATE_LOADING = 'loading';\nexport const DEVICE_STATE_PENDING = 'pending';\nexport const DEVICE_STATE_ERROR = 'error';\nexport const DEVICE_STATE_GRANTED = 'granted';\nexport const DEVICE_STATE_NOT_FOUND = 'not-found';\nexport const DEVICE_STATE_NOT_SUPPORTED = 'not-supported';\nexport const DEVICE_STATE_BLOCKED = 'blocked';\nexport const DEVICE_STATE_IN_USE = 'in-use';\nexport const DEVICE_STATE_OFF = 'off';\nexport const DEVICE_STATE_PLAYABLE = 'playable';\nexport const DEVICE_STATE_SENDABLE = 'sendable';\nexport const useDevices = callObject => {\n  const [deviceState, setDeviceState] = useState(DEVICE_STATE_LOADING);\n  const [currentDevices, setCurrentDevices] = useState(null);\n  const [cams, setCams] = useState([]);\n  const [mics, setMics] = useState([]);\n  const [speakers, setSpeakers] = useState([]);\n  const [camError, setCamError] = useState(null);\n  const [micError, setMicError] = useState(null);\n  const updateDeviceState = useCallback(async () => {\n    var _navigator, _navigator$mediaDevic, _navigator2, _navigator2$mediaDevi;\n\n    if (typeof ((_navigator = navigator) === null || _navigator === void 0 ? void 0 : (_navigator$mediaDevic = _navigator.mediaDevices) === null || _navigator$mediaDevic === void 0 ? void 0 : _navigator$mediaDevic.getUserMedia) === 'undefined' || typeof ((_navigator2 = navigator) === null || _navigator2 === void 0 ? void 0 : (_navigator2$mediaDevi = _navigator2.mediaDevices) === null || _navigator2$mediaDevi === void 0 ? void 0 : _navigator2$mediaDevi.enumerateDevices) === 'undefined') {\n      setDeviceState(DEVICE_STATE_NOT_SUPPORTED);\n      return;\n    }\n\n    try {\n      const {\n        devices\n      } = await callObject.enumerateDevices();\n      const {\n        camera,\n        mic,\n        speaker\n      } = await callObject.getInputDevices();\n      const [defaultCam, ...videoDevices] = devices.filter(d => d.kind === 'videoinput' && d.deviceId !== '');\n      setCams([defaultCam, ...videoDevices.sort((a, b) => sortByKey(a, b, 'label', false))].filter(Boolean));\n      const [defaultMic, ...micDevices] = devices.filter(d => d.kind === 'audioinput' && d.deviceId !== '');\n      setMics([defaultMic, ...micDevices.sort((a, b) => sortByKey(a, b, 'label', false))].filter(Boolean));\n      const [defaultSpeaker, ...speakerDevices] = devices.filter(d => d.kind === 'audiooutput' && d.deviceId !== '');\n      setSpeakers([defaultSpeaker, ...speakerDevices.sort((a, b) => sortByKey(a, b, 'label', false))].filter(Boolean));\n      setCurrentDevices({\n        camera,\n        mic,\n        speaker\n      });\n      console.log(`Current cam: ${camera.label}`);\n      console.log(`Current mic: ${mic.label}`);\n      console.log(`Current speakers: ${speaker.label}`);\n    } catch (e) {\n      setDeviceState(DEVICE_STATE_NOT_SUPPORTED);\n    }\n  }, [callObject]);\n  const updateDeviceErrors = useCallback(() => {\n    var _tracks$video, _tracks$video$blocked, _tracks$video2, _tracks$video2$blocke, _tracks$video3, _tracks$video3$blocke, _tracks$audio, _tracks$audio$blocked, _tracks$audio2, _tracks$audio2$blocke, _tracks$audio3, _tracks$audio3$blocke;\n\n    if (!callObject) return;\n    const {\n      tracks\n    } = callObject.participants().local;\n\n    if ((_tracks$video = tracks.video) === null || _tracks$video === void 0 ? void 0 : (_tracks$video$blocked = _tracks$video.blocked) === null || _tracks$video$blocked === void 0 ? void 0 : _tracks$video$blocked.byPermissions) {\n      setCamError(DEVICE_STATE_BLOCKED);\n    } else if ((_tracks$video2 = tracks.video) === null || _tracks$video2 === void 0 ? void 0 : (_tracks$video2$blocke = _tracks$video2.blocked) === null || _tracks$video2$blocke === void 0 ? void 0 : _tracks$video2$blocke.byDeviceMissing) {\n      setCamError(DEVICE_STATE_NOT_FOUND);\n    } else if ((_tracks$video3 = tracks.video) === null || _tracks$video3 === void 0 ? void 0 : (_tracks$video3$blocke = _tracks$video3.blocked) === null || _tracks$video3$blocke === void 0 ? void 0 : _tracks$video3$blocke.byDeviceInUse) {\n      setCamError(DEVICE_STATE_IN_USE);\n    }\n\n    if ([DEVICE_STATE_LOADING, DEVICE_STATE_OFF, DEVICE_STATE_PLAYABLE, DEVICE_STATE_SENDABLE].includes(tracks.video.state)) {\n      setCamError(null);\n    }\n\n    if ((_tracks$audio = tracks.audio) === null || _tracks$audio === void 0 ? void 0 : (_tracks$audio$blocked = _tracks$audio.blocked) === null || _tracks$audio$blocked === void 0 ? void 0 : _tracks$audio$blocked.byPermissions) {\n      setMicError(DEVICE_STATE_BLOCKED);\n    } else if ((_tracks$audio2 = tracks.audio) === null || _tracks$audio2 === void 0 ? void 0 : (_tracks$audio2$blocke = _tracks$audio2.blocked) === null || _tracks$audio2$blocke === void 0 ? void 0 : _tracks$audio2$blocke.byDeviceMissing) {\n      setMicError(DEVICE_STATE_NOT_FOUND);\n    } else if ((_tracks$audio3 = tracks.audio) === null || _tracks$audio3 === void 0 ? void 0 : (_tracks$audio3$blocke = _tracks$audio3.blocked) === null || _tracks$audio3$blocke === void 0 ? void 0 : _tracks$audio3$blocke.byDeviceInUse) {\n      setMicError(DEVICE_STATE_IN_USE);\n    }\n\n    if ([DEVICE_STATE_LOADING, DEVICE_STATE_OFF, DEVICE_STATE_PLAYABLE, DEVICE_STATE_SENDABLE].includes(tracks.audio.state)) {\n      setMicError(null);\n    }\n  }, [callObject]);\n  const handleParticipantUpdated = useCallback(({\n    participant\n  }) => {\n    if (!callObject || !participant.local) return;\n    setDeviceState(prevState => {\n      if (prevState === DEVICE_STATE_NOT_SUPPORTED) return prevState;\n\n      switch (participant === null || participant === void 0 ? void 0 : participant.tracks.video.state) {\n        case DEVICE_STATE_BLOCKED:\n          updateDeviceErrors();\n          return DEVICE_STATE_ERROR;\n\n        case DEVICE_STATE_OFF:\n        case DEVICE_STATE_PLAYABLE:\n          if (prevState === DEVICE_STATE_GRANTED) {\n            return prevState;\n          }\n\n          updateDeviceState();\n          return DEVICE_STATE_GRANTED;\n\n        default:\n          return prevState;\n      }\n    });\n  }, [callObject, updateDeviceState, updateDeviceErrors]);\n  useEffect(() => {\n    if (!callObject) return false;\n    /**\n      If the user is slow to allow access, we'll update the device state\n      so our app can show a prompt requesting access\n    */\n\n    let pendingAccessTimeout;\n\n    const handleJoiningMeeting = () => {\n      pendingAccessTimeout = setTimeout(() => {\n        setDeviceState(DEVICE_STATE_PENDING);\n      }, 2000);\n    };\n\n    const handleJoinedMeeting = () => {\n      clearTimeout(pendingAccessTimeout); // Note: setOutputDevice() is not honored before join() so we must enumerate again\n\n      updateDeviceState();\n    };\n\n    callObject.on('joining-meeting', handleJoiningMeeting);\n    callObject.on('joined-meeting', handleJoinedMeeting);\n    callObject.on('participant-updated', handleParticipantUpdated);\n    return () => {\n      clearTimeout(pendingAccessTimeout);\n      callObject.off('joining-meeting', handleJoiningMeeting);\n      callObject.off('joined-meeting', handleJoinedMeeting);\n      callObject.off('participant-updated', handleParticipantUpdated);\n    };\n  }, [callObject, handleParticipantUpdated, updateDeviceState]);\n  const setCamDevice = useCallback(async (newCam, useLocalStorage = true) => {\n    var _currentDevices$cam;\n\n    if (!callObject || newCam.deviceId === (currentDevices === null || currentDevices === void 0 ? void 0 : (_currentDevices$cam = currentDevices.cam) === null || _currentDevices$cam === void 0 ? void 0 : _currentDevices$cam.deviceId)) {\n      return;\n    }\n\n    console.log(`ðŸ”› Changing camera device to: ${newCam.label}`);\n\n    if (useLocalStorage) {\n      localStorage.setItem('defaultCamId', newCam.deviceId);\n    }\n\n    await callObject.setInputDevicesAsync({\n      videoDeviceId: newCam.deviceId\n    });\n    setCurrentDevices(prev => ({ ...prev,\n      camera: newCam\n    }));\n  }, [callObject, currentDevices]);\n  const setMicDevice = useCallback(async (newMic, useLocalStorage = true) => {\n    var _currentDevices$mic;\n\n    if (!callObject || newMic.deviceId === (currentDevices === null || currentDevices === void 0 ? void 0 : (_currentDevices$mic = currentDevices.mic) === null || _currentDevices$mic === void 0 ? void 0 : _currentDevices$mic.deviceId)) {\n      return;\n    }\n\n    console.log(`ðŸ”› Changing mic device to: ${newMic.label}`);\n\n    if (useLocalStorage) {\n      localStorage.setItem('defaultMicId', newMic.deviceId);\n    }\n\n    await callObject.setInputDevicesAsync({\n      audioDeviceId: newMic.deviceId\n    });\n    setCurrentDevices(prev => ({ ...prev,\n      mic: newMic\n    }));\n  }, [callObject, currentDevices]);\n  const setSpeakersDevice = useCallback(async (newSpeakers, useLocalStorage = true) => {\n    var _currentDevices$speak;\n\n    if (!callObject || newSpeakers.deviceId === (currentDevices === null || currentDevices === void 0 ? void 0 : (_currentDevices$speak = currentDevices.speaker) === null || _currentDevices$speak === void 0 ? void 0 : _currentDevices$speak.deviceId)) {\n      return;\n    }\n\n    console.log(`Changing speakers device to: ${newSpeakers.label}`);\n\n    if (useLocalStorage) {\n      localStorage.setItem('defaultSpeakersId', newSpeakers.deviceId);\n    }\n\n    callObject.setOutputDevice({\n      outputDeviceId: newSpeakers.deviceId\n    });\n    setCurrentDevices(prev => ({ ...prev,\n      speaker: newSpeakers\n    }));\n  }, [callObject, currentDevices]);\n  useEffect(() => {\n    if (!callObject) return false;\n    console.log('ðŸ’» Device provider events bound');\n\n    const handleCameraError = ({\n      errorMsg: {\n        errorMsg,\n        audioOk,\n        videoOk\n      },\n      error\n    }) => {\n      switch (error === null || error === void 0 ? void 0 : error.type) {\n        case 'cam-in-use':\n          setDeviceState(DEVICE_STATE_ERROR);\n          setCamError(DEVICE_STATE_IN_USE);\n          break;\n\n        case 'mic-in-use':\n          setDeviceState(DEVICE_STATE_ERROR);\n          setMicError(DEVICE_STATE_IN_USE);\n          break;\n\n        case 'cam-mic-in-use':\n          setDeviceState(DEVICE_STATE_ERROR);\n          setCamError(DEVICE_STATE_IN_USE);\n          setMicError(DEVICE_STATE_IN_USE);\n          break;\n\n        default:\n          switch (errorMsg) {\n            case 'devices error':\n              setDeviceState(DEVICE_STATE_ERROR);\n              setCamError(videoOk ? null : DEVICE_STATE_NOT_FOUND);\n              setMicError(audioOk ? null : DEVICE_STATE_NOT_FOUND);\n              break;\n\n            case 'not allowed':\n              setDeviceState(DEVICE_STATE_ERROR);\n              updateDeviceErrors();\n              break;\n\n            default:\n              break;\n          }\n\n          break;\n      }\n    };\n\n    const handleError = ({\n      errorMsg\n    }) => {\n      switch (errorMsg) {\n        case 'not allowed':\n          setDeviceState(DEVICE_STATE_ERROR);\n          updateDeviceErrors();\n          break;\n\n        default:\n          break;\n      }\n    };\n\n    const handleStartedCamera = () => {\n      updateDeviceErrors();\n    };\n\n    callObject.on('camera-error', handleCameraError);\n    callObject.on('error', handleError);\n    callObject.on('started-camera', handleStartedCamera);\n    return () => {\n      callObject.off('camera-error', handleCameraError);\n      callObject.off('error', handleError);\n      callObject.off('started-camera', handleStartedCamera);\n    };\n  }, [callObject, updateDeviceErrors]);\n  return {\n    cams,\n    mics,\n    speakers,\n    camError,\n    micError,\n    currentDevices,\n    deviceState,\n    setCamDevice,\n    setMicDevice,\n    setSpeakersDevice\n  };\n};\nexport default useDevices;","map":{"version":3,"sources":["/Users/arlosb/Documents/GitHub/new react app/test4/src/components/General/Haircheck/Shared/useDevices.js"],"names":["useState","useCallback","useEffect","sortByKey","DEVICE_STATE_LOADING","DEVICE_STATE_PENDING","DEVICE_STATE_ERROR","DEVICE_STATE_GRANTED","DEVICE_STATE_NOT_FOUND","DEVICE_STATE_NOT_SUPPORTED","DEVICE_STATE_BLOCKED","DEVICE_STATE_IN_USE","DEVICE_STATE_OFF","DEVICE_STATE_PLAYABLE","DEVICE_STATE_SENDABLE","useDevices","callObject","deviceState","setDeviceState","currentDevices","setCurrentDevices","cams","setCams","mics","setMics","speakers","setSpeakers","camError","setCamError","micError","setMicError","updateDeviceState","navigator","mediaDevices","getUserMedia","enumerateDevices","devices","camera","mic","speaker","getInputDevices","defaultCam","videoDevices","filter","d","kind","deviceId","sort","a","b","Boolean","defaultMic","micDevices","defaultSpeaker","speakerDevices","console","log","label","e","updateDeviceErrors","tracks","participants","local","video","blocked","byPermissions","byDeviceMissing","byDeviceInUse","includes","state","audio","handleParticipantUpdated","participant","prevState","pendingAccessTimeout","handleJoiningMeeting","setTimeout","handleJoinedMeeting","clearTimeout","on","off","setCamDevice","newCam","useLocalStorage","cam","localStorage","setItem","setInputDevicesAsync","videoDeviceId","prev","setMicDevice","newMic","audioDeviceId","setSpeakersDevice","newSpeakers","setOutputDevice","outputDeviceId","handleCameraError","errorMsg","audioOk","videoOk","error","type","handleError","handleStartedCamera"],"mappings":"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","sourcesContent":["import { useState, useCallback, useEffect } from 'react';\nimport { sortByKey } from '../lib/sortByKey';\n\nexport const DEVICE_STATE_LOADING = 'loading';\nexport const DEVICE_STATE_PENDING = 'pending';\nexport const DEVICE_STATE_ERROR = 'error';\nexport const DEVICE_STATE_GRANTED = 'granted';\nexport const DEVICE_STATE_NOT_FOUND = 'not-found';\nexport const DEVICE_STATE_NOT_SUPPORTED = 'not-supported';\nexport const DEVICE_STATE_BLOCKED = 'blocked';\nexport const DEVICE_STATE_IN_USE = 'in-use';\nexport const DEVICE_STATE_OFF = 'off';\nexport const DEVICE_STATE_PLAYABLE = 'playable';\nexport const DEVICE_STATE_SENDABLE = 'sendable';\n\nexport const useDevices = (callObject) => {\n  const [deviceState, setDeviceState] = useState(DEVICE_STATE_LOADING);\n  const [currentDevices, setCurrentDevices] = useState(null);\n\n  const [cams, setCams] = useState([]);\n  const [mics, setMics] = useState([]);\n  const [speakers, setSpeakers] = useState([]);\n\n  const [camError, setCamError] = useState(null);\n  const [micError, setMicError] = useState(null);\n\n  const updateDeviceState = useCallback(async () => {\n    if (\n      typeof navigator?.mediaDevices?.getUserMedia === 'undefined' ||\n      typeof navigator?.mediaDevices?.enumerateDevices === 'undefined'\n    ) {\n      setDeviceState(DEVICE_STATE_NOT_SUPPORTED);\n      return;\n    }\n\n    try {\n      const { devices } = await callObject.enumerateDevices();\n\n      const { camera, mic, speaker } = await callObject.getInputDevices();\n\n      const [defaultCam, ...videoDevices] = devices.filter(\n        (d) => d.kind === 'videoinput' && d.deviceId !== ''\n      );\n      setCams(\n        [\n          defaultCam,\n          ...videoDevices.sort((a, b) => sortByKey(a, b, 'label', false)),\n        ].filter(Boolean)\n      );\n      const [defaultMic, ...micDevices] = devices.filter(\n        (d) => d.kind === 'audioinput' && d.deviceId !== ''\n      );\n      setMics(\n        [\n          defaultMic,\n          ...micDevices.sort((a, b) => sortByKey(a, b, 'label', false)),\n        ].filter(Boolean)\n      );\n      const [defaultSpeaker, ...speakerDevices] = devices.filter(\n        (d) => d.kind === 'audiooutput' && d.deviceId !== ''\n      );\n      setSpeakers(\n        [\n          defaultSpeaker,\n          ...speakerDevices.sort((a, b) => sortByKey(a, b, 'label', false)),\n        ].filter(Boolean)\n      );\n\n      setCurrentDevices({\n        camera,\n        mic,\n        speaker,\n      });\n\n      console.log(`Current cam: ${camera.label}`);\n      console.log(`Current mic: ${mic.label}`);\n      console.log(`Current speakers: ${speaker.label}`);\n    } catch (e) {\n      setDeviceState(DEVICE_STATE_NOT_SUPPORTED);\n    }\n  }, [callObject]);\n\n  const updateDeviceErrors = useCallback(() => {\n    if (!callObject) return;\n    const { tracks } = callObject.participants().local;\n\n    if (tracks.video?.blocked?.byPermissions) {\n      setCamError(DEVICE_STATE_BLOCKED);\n    } else if (tracks.video?.blocked?.byDeviceMissing) {\n      setCamError(DEVICE_STATE_NOT_FOUND);\n    } else if (tracks.video?.blocked?.byDeviceInUse) {\n      setCamError(DEVICE_STATE_IN_USE);\n    }\n\n    if (\n      [\n        DEVICE_STATE_LOADING,\n        DEVICE_STATE_OFF,\n        DEVICE_STATE_PLAYABLE,\n        DEVICE_STATE_SENDABLE,\n      ].includes(tracks.video.state)\n    ) {\n      setCamError(null);\n    }\n\n    if (tracks.audio?.blocked?.byPermissions) {\n      setMicError(DEVICE_STATE_BLOCKED);\n    } else if (tracks.audio?.blocked?.byDeviceMissing) {\n      setMicError(DEVICE_STATE_NOT_FOUND);\n    } else if (tracks.audio?.blocked?.byDeviceInUse) {\n      setMicError(DEVICE_STATE_IN_USE);\n    }\n\n    if (\n      [\n        DEVICE_STATE_LOADING,\n        DEVICE_STATE_OFF,\n        DEVICE_STATE_PLAYABLE,\n        DEVICE_STATE_SENDABLE,\n      ].includes(tracks.audio.state)\n    ) {\n      setMicError(null);\n    }\n  }, [callObject]);\n\n  const handleParticipantUpdated = useCallback(\n    ({ participant }) => {\n      if (!callObject || !participant.local) return;\n\n      setDeviceState((prevState) => {\n        if (prevState === DEVICE_STATE_NOT_SUPPORTED) return prevState;\n        switch (participant?.tracks.video.state) {\n          case DEVICE_STATE_BLOCKED:\n            updateDeviceErrors();\n            return DEVICE_STATE_ERROR;\n          case DEVICE_STATE_OFF:\n          case DEVICE_STATE_PLAYABLE:\n            if (prevState === DEVICE_STATE_GRANTED) {\n              return prevState;\n            }\n            updateDeviceState();\n            return DEVICE_STATE_GRANTED;\n          default:\n            return prevState;\n        }\n      });\n    },\n    [callObject, updateDeviceState, updateDeviceErrors]\n  );\n\n  useEffect(() => {\n    if (!callObject) return false;\n\n    /**\n      If the user is slow to allow access, we'll update the device state\n      so our app can show a prompt requesting access\n    */\n    let pendingAccessTimeout;\n\n    const handleJoiningMeeting = () => {\n      pendingAccessTimeout = setTimeout(() => {\n        setDeviceState(DEVICE_STATE_PENDING);\n      }, 2000);\n    };\n\n    const handleJoinedMeeting = () => {\n      clearTimeout(pendingAccessTimeout);\n      // Note: setOutputDevice() is not honored before join() so we must enumerate again\n      updateDeviceState();\n    };\n\n    callObject.on('joining-meeting', handleJoiningMeeting);\n    callObject.on('joined-meeting', handleJoinedMeeting);\n    callObject.on('participant-updated', handleParticipantUpdated);\n    return () => {\n      clearTimeout(pendingAccessTimeout);\n      callObject.off('joining-meeting', handleJoiningMeeting);\n      callObject.off('joined-meeting', handleJoinedMeeting);\n      callObject.off('participant-updated', handleParticipantUpdated);\n    };\n  }, [callObject, handleParticipantUpdated, updateDeviceState]);\n\n  const setCamDevice = useCallback(\n    async (newCam, useLocalStorage = true) => {\n      if (!callObject || newCam.deviceId === currentDevices?.cam?.deviceId) {\n        return;\n      }\n\n      console.log(`ðŸ”› Changing camera device to: ${newCam.label}`);\n\n      if (useLocalStorage) {\n        localStorage.setItem('defaultCamId', newCam.deviceId);\n      }\n\n      await callObject.setInputDevicesAsync({\n        videoDeviceId: newCam.deviceId,\n      });\n\n      setCurrentDevices((prev) => ({ ...prev, camera: newCam }));\n    },\n    [callObject, currentDevices]\n  );\n\n  const setMicDevice = useCallback(\n    async (newMic, useLocalStorage = true) => {\n      if (!callObject || newMic.deviceId === currentDevices?.mic?.deviceId) {\n        return;\n      }\n\n      console.log(`ðŸ”› Changing mic device to: ${newMic.label}`);\n\n      if (useLocalStorage) {\n        localStorage.setItem('defaultMicId', newMic.deviceId);\n      }\n\n      await callObject.setInputDevicesAsync({\n        audioDeviceId: newMic.deviceId,\n      });\n\n      setCurrentDevices((prev) => ({ ...prev, mic: newMic }));\n    },\n    [callObject, currentDevices]\n  );\n\n  const setSpeakersDevice = useCallback(\n    async (newSpeakers, useLocalStorage = true) => {\n      if (\n        !callObject ||\n        newSpeakers.deviceId === currentDevices?.speaker?.deviceId\n      ) {\n        return;\n      }\n\n      console.log(`Changing speakers device to: ${newSpeakers.label}`);\n\n      if (useLocalStorage) {\n        localStorage.setItem('defaultSpeakersId', newSpeakers.deviceId);\n      }\n\n      callObject.setOutputDevice({\n        outputDeviceId: newSpeakers.deviceId,\n      });\n\n      setCurrentDevices((prev) => ({ ...prev, speaker: newSpeakers }));\n    },\n    [callObject, currentDevices]\n  );\n\n  useEffect(() => {\n    if (!callObject) return false;\n\n    console.log('ðŸ’» Device provider events bound');\n\n    const handleCameraError = ({\n      errorMsg: { errorMsg, audioOk, videoOk },\n      error,\n    }) => {\n      switch (error?.type) {\n        case 'cam-in-use':\n          setDeviceState(DEVICE_STATE_ERROR);\n          setCamError(DEVICE_STATE_IN_USE);\n          break;\n        case 'mic-in-use':\n          setDeviceState(DEVICE_STATE_ERROR);\n          setMicError(DEVICE_STATE_IN_USE);\n          break;\n        case 'cam-mic-in-use':\n          setDeviceState(DEVICE_STATE_ERROR);\n          setCamError(DEVICE_STATE_IN_USE);\n          setMicError(DEVICE_STATE_IN_USE);\n          break;\n        default:\n          switch (errorMsg) {\n            case 'devices error':\n              setDeviceState(DEVICE_STATE_ERROR);\n              setCamError(videoOk ? null : DEVICE_STATE_NOT_FOUND);\n              setMicError(audioOk ? null : DEVICE_STATE_NOT_FOUND);\n              break;\n            case 'not allowed':\n              setDeviceState(DEVICE_STATE_ERROR);\n              updateDeviceErrors();\n              break;\n            default:\n              break;\n          }\n          break;\n      }\n    };\n\n    const handleError = ({ errorMsg }) => {\n      switch (errorMsg) {\n        case 'not allowed':\n          setDeviceState(DEVICE_STATE_ERROR);\n          updateDeviceErrors();\n          break;\n        default:\n          break;\n      }\n    };\n\n    const handleStartedCamera = () => {\n      updateDeviceErrors();\n    };\n\n    callObject.on('camera-error', handleCameraError);\n    callObject.on('error', handleError);\n    callObject.on('started-camera', handleStartedCamera);\n    return () => {\n      callObject.off('camera-error', handleCameraError);\n      callObject.off('error', handleError);\n      callObject.off('started-camera', handleStartedCamera);\n    };\n  }, [callObject, updateDeviceErrors]);\n\n  return {\n    cams,\n    mics,\n    speakers,\n    camError,\n    micError,\n    currentDevices,\n    deviceState,\n    setCamDevice,\n    setMicDevice,\n    setSpeakersDevice,\n  };\n};\n\nexport default useDevices;"]},"metadata":{},"sourceType":"module"}