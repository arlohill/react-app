{"ast":null,"code":"import _slicedToArray from\"/Users/arlosb/Documents/GitHub/new react app/test4/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import React,{useEffect,useMemo,useRef,useState}from'react';import'./Tile.css';function useForceUpdate(){var _useState=useState(0),_useState2=_slicedToArray(_useState,2),value=_useState2[0],setValue=_useState2[1];// integer state\nreturn function(){return setValue(function(value){return value+1;});};// update the state to force render\n}function getTrackUnavailableMessage(kind,trackState){if(!trackState)return;switch(trackState.state){case'blocked':if(trackState.blocked.byPermissions){return\"\".concat(kind,\" permission denied\");}else if(trackState.blocked.byDeviceMissing){return\"\".concat(kind,\" device missing\");}return\"\".concat(kind,\" blocked\");case'off':if(trackState.off.byUser){return\"\".concat(kind,\" muted\");}else if(trackState.off.byBandwidth){return\"\".concat(kind,\" muted to save bandwidth\");}return\"\".concat(kind,\" off\");case'sendable':return\"\".concat(kind,\" not subscribed\");case'loading':return\"\".concat(kind,\" loading...\");case'interrupted':return\"\".concat(kind,\" interrupted\");case'playable':return null;}}/**\n * Props\n * - videoTrackState: DailyTrackState?\n * - audioTrackState: DailyTrackState?\n * - isLocalPerson: boolean\n * - isAudioOnly: boolean\n * - isLarge: boolean\n * - disableCornerMessage: boolean\n * - onClick: Function\n * -isScreenShare: boolean\n */export default function Tile(props){var videoEl=useRef(null);var audioEl=useRef(null);var forceUpdate=useForceUpdate();window.updateTile=function(){forceUpdate();};var videoTrack=useMemo(function(){return props.videoTrackState&&props.videoTrackState.state==='playable'&&(props.isLocalPerson||props.videoTrackState.subscribed===true)?props.videoTrackState.track:null;},[props.videoTrackState]);var subscribed=useMemo(function(){//should be considered \"subscribed\" if video track is non-local + subscribed (even if the cam is off, to render black background), OR if it's local and cam is on\nreturn props.videoTrackState&&(props.isLocalPerson&&props.videoTrackState.state==='playable'||props.videoTrackState.subscribed);},[props.videoTrackState]);var audioTrack=useMemo(function(){if(!props.audioTrackState||!props.audioTrackState.track||props.audioTrackState.state!=='playable'||props.audioTrackState.subscribed===false){return null;}// if(props.disableCornerMessage) {console.log('Is a screen share');}\nif(props.isAudioOnly){props.audioTrackState.track.isFiltered=true;}else{props.audioTrackState.track.isFiltered=false;}if(props.isScreenShare){props.audioTrackState.track.isScreenShare=true;}else{props.audioTrackState.track.isScreenShare=false;}return props.audioTrackState.track;},[props.audioTrackState]);var videoUnavailableMessage=useMemo(function(){return getTrackUnavailableMessage('video',props.videoTrackState);},[props.videoTrackState]);var audioUnavailableMessage=useMemo(function(){return getTrackUnavailableMessage('audio',props.audioTrackState);},[props.audioTrackState]);/**\n   * When video track changes, update video srcObject\n   */useEffect(function(){videoEl.current&&(videoEl.current.srcObject=new MediaStream([videoTrack]));},[videoTrack]);/**\n   * When audio track changes, update audio srcObject\n   */useEffect(function(){if(audioEl.current){///////////////TODO START TEMP DELETED PORTION\nif(audioTrack.isFiltered){console.log('**FILTERING LIVE TRACK**');///******audiocontext creation section///\n//create audio stream\nwindow.stream=new MediaStream([audioTrack]);//workaround for bug in Chrome, see: https://bit.ly/3ryn1fW\nwindow.mutedAudio=window.mutedAudio||new Audio();window.mutedAudio.muted=true;if(!window.mutedAudio.srcObject){window.mutedAudio.srcObject=window.stream;}window.mutedAudio.paused&&window.mutedAudio.play();//create Audio Context and destination\nwindow.audioCtx=window.audioCtx||new(window.AudioContext||window.webkitAudioContext)();window.audioSourceNode=window.audioCtx.createMediaStreamSource(window.stream);if(typeof window.destination=='undefined'){window.destination=window.audioCtx.createMediaStreamDestination();}//gain Node\nif(typeof window.gainNode=='undefined'){window.gainNode=window.audioCtx.createGain();}//panner Node\nif(typeof window.panNode=='undefined'){window.panNode=window.audioCtx.createStereoPanner();}//*****end audiocontext creation section\n//adjust nodes\nwindow.gainNode.gain.value=1;window.panNode.pan.value=1;//Pipe source through nodes to destination\nwindow.audioSourceNode.connect(window.gainNode).connect(window.panNode).connect(window.destination);//Attach to the audio element\naudioEl.current.srcObject=window.destination.stream;}else if(audioTrack.isScreenShare){//for everyone, just piping the received audio (which was the left channel of the original video) straight through\nconsole.log('***GETTING SCREENSHARE AUDIO');///***With audiocontext:  */\n// window.audioSourceNode.connect(destination);\n///without Audiocontext:////\naudioEl.current.srcObject=new MediaStream([audioTrack]);}else{//For normal live tracks\nconsole.log('***NOT FILTERING: LIVE TRACK***');//Pipe source *straight* to destination, through audiocontext\n// window.audioSourceNode.connect(gainNode).connect(destination);\n//without audiocontext\naudioEl.current.srcObject=new MediaStream([audioTrack]);}///END TODO TEMP DELETED PORTION\n//when above is deleted:\n//  audioEl.current.srcObject = new MediaStream([audioTrack]);\n// for debugging\n// window.destination=destination; \n// window.audioTrack=audioTrack;\n// window.audioEl = audioEl;\n}},[audioTrack,window.sessionState]);function getVideoComponent(){return videoTrack&&/*#__PURE__*/React.createElement(\"video\",{autoPlay:true,muted:true,playsInline:true,ref:videoEl});}function getAudioComponent(){return!props.isLocalPerson&&audioTrack&&/*#__PURE__*/React.createElement(\"audio\",{autoPlay:true,playsInline:true,ref:audioEl},\" \");}function getOverlayComponent(){// Show overlay when video is unavailable. Audio may be unavailable too.\nreturn videoTrack&&videoUnavailableMessage&&/*#__PURE__*/React.createElement(\"p\",{className:\"overlay\"},videoUnavailableMessage);}function getCornerMessageComponent(){// Show corner message when only audio is unavailable.\nreturn!props.disableCornerMessage&&audioUnavailableMessage&&!videoUnavailableMessage&&/*#__PURE__*/React.createElement(\"p\",{className:\"corner\"},audioUnavailableMessage);}function getClassNames(){var classNames='tile';classNames+=props.isLarge?' large':' small';props.isLocalPerson&&(classNames+=' local');return classNames;}return/*#__PURE__*/ (///TODO change to block : none (otherwise will show black background even when not subscribed)\nReact.createElement(\"div\",{className:getClassNames(),onClick:props.onClick,style:{display:subscribed?\"block\":\"none\"}},/*#__PURE__*/React.createElement(\"div\",{className:\"background\"}),getOverlayComponent(),getVideoComponent(),videoTrack&&getCornerMessageComponent(),getAudioComponent()));}","map":null,"metadata":{},"sourceType":"module"}